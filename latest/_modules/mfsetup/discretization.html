<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mfsetup.discretization &mdash; modflow-setup 0.2.0.post23+g97c0995 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            modflow-setup
          </a>
              <div class="version">
                0.2.0.post23+g97c0995
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../philosophy.html">     Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html"> Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html"> Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config-file-gallery.html"> Configuration File Gallery</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../structure.html"> Basic program structure and usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config-file.html"> The configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts/index.html"> Concepts and methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html"> Input instructions by package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html"> Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html"> Code reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config-file-defaults.html"> Configuration file defaults</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release-history.html"> Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html"> Contributing to modflow-setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../references.html"> References cited</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">modflow-setup</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mfsetup.discretization</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mfsetup.discretization</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions related to the Discretization Package.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">re</span> <span class="kn">import</span> <span class="n">L</span>

<span class="kn">import</span> <span class="nn">flopy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">flopy.mf6.data.mfdatalist</span> <span class="kn">import</span> <span class="n">MFList</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">convolve2d</span>


<div class="viewcode-block" id="ModflowGwfdis"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.ModflowGwfdis">[docs]</a><span class="k">class</span> <span class="nc">ModflowGwfdis</span><span class="p">(</span><span class="n">flopy</span><span class="o">.</span><span class="n">mf6</span><span class="o">.</span><span class="n">ModflowGwfdis</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">flopy</span><span class="o">.</span><span class="n">mf6</span><span class="o">.</span><span class="n">ModflowGwfdis</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">thickness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">array</span><span class="p">]</span> <span class="o">+</span>
                                     <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">botm</span><span class="o">.</span><span class="n">array</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="adjust_layers"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.adjust_layers">[docs]</a><span class="k">def</span> <span class="nf">adjust_layers</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">minimum_thickness</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust bottom layer elevations to maintain a minimum thickness.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dis : flopy.modflow.ModflowDis instance</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_layer_elevs : ndarray of shape (nlay, ncol, nrow)</span>
<span class="sd">        New layer bottom elevations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">,</span> <span class="n">nlay</span><span class="p">,</span> <span class="n">nper</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nrow_ncol_nlay_nper</span>
    <span class="n">new_layer_elevs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nlay</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">))</span>
    <span class="n">new_layer_elevs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">array</span>
    <span class="n">new_layer_elevs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="n">botm</span><span class="o">.</span><span class="n">array</span>

    <span class="c1"># constrain everything to model top</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nlay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">thicknesses</span> <span class="o">=</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">too_thin</span> <span class="o">=</span> <span class="n">thicknesses</span> <span class="o">&lt;</span> <span class="n">minimum_thickness</span> <span class="o">*</span> <span class="n">i</span>
        <span class="n">new_layer_elevs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">too_thin</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">too_thin</span><span class="p">]</span> <span class="o">-</span> <span class="n">minimum_thickness</span> <span class="o">*</span> <span class="n">i</span>

    <span class="c1"># constrain to underlying botms</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nlay</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">thicknesses</span> <span class="o">=</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">too_thin</span> <span class="o">=</span> <span class="n">thicknesses</span> <span class="o">&lt;</span> <span class="n">minimum_thickness</span>
        <span class="n">new_layer_elevs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">too_thin</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">too_thin</span><span class="p">]</span> <span class="o">+</span> <span class="n">minimum_thickness</span>

    <span class="k">return</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span></div>


<div class="viewcode-block" id="deactivate_idomain_above"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.deactivate_idomain_above">[docs]</a><span class="k">def</span> <span class="nf">deactivate_idomain_above</span><span class="p">(</span><span class="n">idomain</span><span class="p">,</span> <span class="n">packagedata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sets ibound to 0 for all cells above active SFR cells.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    packagedata : MFList, recarray or DataFrame</span>
<span class="sd">        SFR package reach data</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This routine updates the ibound array of the flopy.model.ModflowBas6 instance. To produce a</span>
<span class="sd">    new BAS6 package file, model.write() or flopy.model.ModflowBas6.write()</span>
<span class="sd">    must be run.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">packagedata</span><span class="p">,</span> <span class="n">MFList</span><span class="p">):</span>
        <span class="n">packagedata</span> <span class="o">=</span> <span class="n">packagedata</span><span class="o">.</span><span class="n">array</span>
    <span class="n">idomain</span> <span class="o">=</span> <span class="n">idomain</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">packagedata</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">):</span>
        <span class="n">packagedata</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">packagedata</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
    <span class="k">if</span> <span class="s1">&#39;cellid&#39;</span> <span class="ow">in</span> <span class="n">packagedata</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">cellids_to_kij</span><span class="p">(</span><span class="n">packagedata</span><span class="p">[</span><span class="s1">&#39;cellid&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">packagedata</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="n">packagedata</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">],</span> <span class="n">packagedata</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span>
    <span class="n">deact_lays</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ki</span><span class="p">))</span> <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ks</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">cj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">deact_lays</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ck</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">:</span>
            <span class="n">idomain</span><span class="p">[</span><span class="n">ck</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">cj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">idomain</span></div>


<div class="viewcode-block" id="find_remove_isolated_cells"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.find_remove_isolated_cells">[docs]</a><span class="k">def</span> <span class="nf">find_remove_isolated_cells</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">minimum_cluster_size</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify clusters of isolated cells in a binary array.</span>
<span class="sd">    Remove clusters less than a specified minimum cluster size.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">arraylist</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arraylist</span> <span class="o">=</span> <span class="n">array</span>

    <span class="c1"># exclude diagonal connections</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">structure</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">structure</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">retained_arraylist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arraylist</span><span class="p">:</span>

        <span class="c1"># for each cell in the binary array arr (i.e. representing active cells)</span>
        <span class="c1"># take the sum of the cell and 4 immediate neighbors (excluding diagonal connections)</span>
        <span class="c1"># values &gt; 2 in the output array indicate cells with at least two connections</span>
        <span class="n">convolved</span> <span class="o">=</span> <span class="n">convolve2d</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="c1"># taking union with (arr == 1) prevents inactive cells from being activated</span>
        <span class="n">atleast_2_connections</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">convolved</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># then apply connected component analysis</span>
        <span class="c1"># to identify small clusters of isolated cells to exclude</span>
        <span class="n">labeled</span><span class="p">,</span> <span class="n">ncomponents</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">atleast_2_connections</span><span class="p">,</span>
                                                          <span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">)</span>
        <span class="n">retain_areas</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncomponents</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">labeled</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">minimum_cluster_size</span><span class="p">]</span>
        <span class="n">retain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">labeled</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">retain_areas</span><span class="p">)</span>
        <span class="n">retained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">retain</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">retained_arraylist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">retained</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">retained_arraylist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">retained_arraylist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="cellids_to_kij"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.cellids_to_kij">[docs]</a><span class="k">def</span> <span class="nf">cellids_to_kij</span><span class="p">(</span><span class="n">cellids</span><span class="p">,</span> <span class="n">drop_inactive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unpack tuples of MODFLOW-6 cellids (k, i, j) to</span>
<span class="sd">    lists of k, i, j values; ignoring instances</span>
<span class="sd">    where cellid is None (unconnected cells).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cellids : sequence of (k, i, j) tuples</span>
<span class="sd">    drop_inactive : bool</span>
<span class="sd">        If True, drop cellids == &#39;none&#39;. If False,</span>
<span class="sd">        distribute these to k, i, j.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    k, i, j : 1D numpy arrays of integers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">active</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span>
    <span class="k">if</span> <span class="n">drop_inactive</span><span class="p">:</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">cellids</span><span class="p">[</span><span class="n">active</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">cid</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cellids</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">cid</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cellids</span><span class="p">])</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cid</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">cid</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cellids</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span></div>


<div class="viewcode-block" id="create_vertical_pass_through_cells"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.create_vertical_pass_through_cells">[docs]</a><span class="k">def</span> <span class="nf">create_vertical_pass_through_cells</span><span class="p">(</span><span class="n">idomain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replaces inactive cells with vertical pass-through cells at locations that have an active cell</span>
<span class="sd">    above and below by setting these cells to -1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    idomain : np.ndarray with 2 or 3 dimensions. 2D arrays are returned as-is.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    revised : np.ndarray</span>
<span class="sd">        idomain with -1s added at locations that were previous &lt;= 0</span>
<span class="sd">        that have an active cell (idomain=1) above and below.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idomain</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">idomain</span>
    <span class="n">revised</span> <span class="o">=</span> <span class="n">idomain</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">idomain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">has_active_above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idomain</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">has_active_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idomain</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">bounded</span> <span class="o">=</span> <span class="n">has_active_above</span> <span class="o">&amp;</span> <span class="n">has_active_below</span>
        <span class="n">pass_through</span> <span class="o">=</span> <span class="p">(</span><span class="n">idomain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bounded</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">revised</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pass_through</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">revised</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pass_through</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># scrub any pass through cells that aren&#39;t bounded by active cells</span>
        <span class="n">revised</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="n">idomain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">bounded</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">revised</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">revised</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">revised</span></div>


<div class="viewcode-block" id="fill_empty_layers"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.fill_empty_layers">[docs]</a><span class="k">def</span> <span class="nf">fill_empty_layers</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fill empty layers in a 3D array by linearly interpolating</span>
<span class="sd">    between the values above and below. Layers are defined</span>
<span class="sd">    as empty if they contain all nan values. In the example of</span>
<span class="sd">    model layer elevations, this would create equal layer thicknesses</span>
<span class="sd">    between layer surfaces with values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : 3D numpy.ndarray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    filled : ndarray of same shape as array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">get_next_below</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">item</span>

    <span class="k">def</span> <span class="nf">get_next_above</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seq</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">item</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">nlay</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">layers_with_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlay</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))]</span>
    <span class="n">empty_layers</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlay</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">layers_with_values</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">empty_layers</span><span class="p">:</span>
        <span class="n">nextabove</span> <span class="o">=</span> <span class="n">get_next_above</span><span class="p">(</span><span class="n">layers_with_values</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">nextbelow</span> <span class="o">=</span> <span class="n">get_next_below</span><span class="p">(</span><span class="n">layers_with_values</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="c1"># linearly interpolate layer values between next layers</span>
        <span class="c1"># above and below that have values</span>
        <span class="c1"># (in terms of elevation</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nextbelow</span> <span class="o">-</span> <span class="n">nextabove</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">nextbelow</span><span class="p">]</span> <span class="o">-</span> <span class="n">array</span><span class="p">[</span><span class="n">nextabove</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">nextbelow</span><span class="p">):</span>
            <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">array</span></div>


<div class="viewcode-block" id="fill_cells_vertically"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.fill_cells_vertically">[docs]</a><span class="k">def</span> <span class="nf">fill_cells_vertically</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">botm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;In MODFLOW 6, cells where idomain != 1 are excluded from the solution.</span>
<span class="sd">    However, in the botm array, values are needed in overlying cells to</span>
<span class="sd">    compute layer thickness (cells with idomain != 1 overlying cells with idomain &gt;= 1 need</span>
<span class="sd">    values in botm). Given a 3D numpy array with nan values indicating excluded cells,</span>
<span class="sd">    fill in the nans with the overlying values. For example, given the column of cells</span>
<span class="sd">    [10, nan, 8, nan, nan, 5, nan, nan, nan, 1], fill the nan values to make</span>
<span class="sd">    [10, 10, 8, 8, 8, 5, 5, 5, 5], so that layers 2, 5, and 9 (zero-based)</span>
<span class="sd">    all have valid thicknesses (and all other layers have zero thicknesses).</span>

<span class="sd">    algorithm:</span>
<span class="sd">        * given a top and botm array (top of the model and layer bottom elevations),</span>
<span class="sd">          get the layer thicknesses (accounting for any nodata values) idomain != 1 cells in</span>
<span class="sd">          thickness array must be set to np.nan</span>
<span class="sd">        * set thickness to zero in nan cells take the cumulative sum of the thickness array</span>
<span class="sd">          along the 0th (depth) axis, from the bottom of the array to the top</span>
<span class="sd">          (going backwards in a depth-positive sense)</span>
<span class="sd">        * add the cumulative sum to the array bottom elevations. The backward difference in</span>
<span class="sd">          bottom elevations should be zero in inactive cells, and representative of the</span>
<span class="sd">          desired thickness in the active cells.</span>
<span class="sd">        * append the model bottom elevations (excluded in bottom-up difference)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    top : 2D numpy array; model top elevations</span>
<span class="sd">    botm : 3D (nlay, nrow, ncol) array; model bottom elevations</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    top, botm : filled top and botm arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="n">get_layer_thicknesses</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">botm</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">thickness</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">thickness</span><span class="p">)]))</span>
    <span class="n">thickness</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">thickness</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># cumulative sum from bottom to top</span>
    <span class="n">filled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">thickness</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># add in the model bottom elevations</span>
    <span class="c1"># use the minimum values instead of the bottom layer,</span>
    <span class="c1"># in case there are nans in the bottom layer</span>
    <span class="n">filled</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">botm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># botm[-1]</span>
    <span class="c1"># append the model bottom elevations</span>
    <span class="n">filled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filled</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">botm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">filled</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="fix_model_layer_conflicts"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.fix_model_layer_conflicts">[docs]</a><span class="k">def</span> <span class="nf">fix_model_layer_conflicts</span><span class="p">(</span><span class="n">top_array</span><span class="p">,</span> <span class="n">botm_array</span><span class="p">,</span>
                              <span class="n">ibound_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">minimum_thickness</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compare model layer elevations; adjust layer bottoms downward</span>
<span class="sd">    as necessary to maintain a minimum thickness.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    top_array : 2D numpy array (nrow * ncol)</span>
<span class="sd">        Model top elevations</span>
<span class="sd">    botm_array : 3D numpy array (nlay * nrow * ncol)</span>
<span class="sd">        Model bottom elevations</span>
<span class="sd">    minimum thickness : scalar</span>
<span class="sd">        Minimum layer thickness to enforce</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_botm_array : 3D numpy array of new layer bottom elevations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">top_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">botm</span> <span class="o">=</span> <span class="n">botm_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">nlay</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span> <span class="o">=</span> <span class="n">botm</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">ibound_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ibound_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">botm</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># fix thin layers in the DIS package</span>
    <span class="n">new_layer_elevs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nlay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">))</span>
    <span class="n">new_layer_elevs</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">botm</span>
    <span class="n">new_layer_elevs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">top</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nlay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">active</span> <span class="o">=</span> <span class="n">ibound_array</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span>
        <span class="n">thicknesses</span> <span class="o">=</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">too_thin</span> <span class="o">=</span> <span class="n">active</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">thicknesses</span> <span class="o">&lt;</span> <span class="n">minimum_thickness</span><span class="p">)</span>
        <span class="n">new_layer_elevs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">too_thin</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">too_thin</span><span class="p">]</span> <span class="o">-</span> <span class="n">minimum_thickness</span> <span class="o">*</span> <span class="mf">1.001</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">new_layer_elevs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="n">ibound_array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">minimum_thickness</span>
    <span class="k">return</span> <span class="n">new_layer_elevs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span></div>


<div class="viewcode-block" id="get_layer"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.get_layer">[docs]</a><span class="k">def</span> <span class="nf">get_layer</span><span class="p">(</span><span class="n">botm_array</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">elev</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the layers for elevations at i, j locations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    botm_array : 3D numpy array of layer bottom elevations</span>
<span class="sd">    i : scaler or sequence</span>
<span class="sd">        row index (zero-based)</span>
<span class="sd">    j : scaler or sequence</span>
<span class="sd">        column index</span>
<span class="sd">    elev : scaler or sequence</span>
<span class="sd">        elevation (in same units as model)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    k : np.ndarray (1-D) or scalar</span>
<span class="sd">        zero-based layer index</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">arg</span><span class="p">])</span>
        <span class="c1">#if not isinstance(arg, np.ndarray):</span>
        <span class="c1">#    return np.array([arg])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">to_array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">to_array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="n">nlay</span> <span class="o">=</span> <span class="n">botm_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">elev</span> <span class="o">=</span> <span class="n">to_array</span><span class="p">(</span><span class="n">elev</span><span class="p">)</span>
    <span class="n">botms</span> <span class="o">=</span> <span class="n">botm_array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">botms</span> <span class="o">-</span> <span class="n">elev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># force elevations below model bottom into bottom layer</span>
    <span class="n">layers</span><span class="p">[</span><span class="n">layers</span> <span class="o">&gt;</span> <span class="n">nlay</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nlay</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">layers</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">layers</span></div>


<div class="viewcode-block" id="verify_minimum_layer_thickness"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.verify_minimum_layer_thickness">[docs]</a><span class="k">def</span> <span class="nf">verify_minimum_layer_thickness</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">botm</span><span class="p">,</span> <span class="n">isactive</span><span class="p">,</span> <span class="n">minimum_layer_thickness</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify that model layer thickness is equal to or</span>
<span class="sd">    greater than a minimum thickness.&quot;&quot;&quot;</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">botm</span> <span class="o">=</span> <span class="n">botm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">isactive</span> <span class="o">=</span> <span class="n">isactive</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">nlay</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span> <span class="o">=</span> <span class="n">botm</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">all_layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nlay</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">))</span>
    <span class="n">all_layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">top</span>
    <span class="n">all_layers</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">botm</span>
    <span class="n">isvalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">all_layers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="n">isactive</span><span class="p">])</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-4</span> <span class="o">&gt;=</span> \
              <span class="n">minimum_layer_thickness</span>
    <span class="k">return</span> <span class="n">isvalid</span></div>


<div class="viewcode-block" id="make_ibound"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.make_ibound">[docs]</a><span class="k">def</span> <span class="nf">make_ibound</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">botm</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=-</span><span class="mi">9999</span><span class="p">,</span>
                 <span class="n">minimum_layer_thickness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">drop_thin_cells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make the ibound array that specifies</span>
<span class="sd">    cells that will be excluded from the simulation. Cells are</span>
<span class="sd">    excluded based on:</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : mfsetup.MFnwtModel model instance</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idomain : np.ndarray (int)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">botm</span> <span class="o">=</span> <span class="n">botm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">top</span><span class="p">[</span><span class="n">top</span> <span class="o">==</span> <span class="n">nodata</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">botm</span><span class="p">[</span><span class="n">botm</span> <span class="o">==</span> <span class="n">nodata</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">botm</span><span class="p">)</span>

    <span class="c1"># compute layer thicknesses, considering pinched cells (nans)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">get_layer_thicknesses</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">botm</span><span class="p">)</span>
    <span class="n">all_cells_thin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">minimum_layer_thickness</span> <span class="o">+</span> <span class="n">tol</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="n">criteria</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># cells without thickness values</span>

    <span class="k">if</span> <span class="n">drop_thin_cells</span><span class="p">:</span>
        <span class="n">criteria</span> <span class="o">=</span> <span class="n">criteria</span> <span class="o">|</span> <span class="n">all_cells_thin</span>
        <span class="c1">#all_layers = np.stack([top] + [b for b in botm])</span>
        <span class="c1">#min_layer_thickness = minimum_layer_thickness</span>
        <span class="c1">#isthin = np.diff(all_layers, axis=0) * -1 &lt; min_layer_thickness + tol</span>
        <span class="c1">#criteria = criteria | isthin</span>
    <span class="n">idomain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="o">~</span><span class="n">criteria</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">idomain</span></div>


<div class="viewcode-block" id="make_lgr_idomain"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.make_lgr_idomain">[docs]</a><span class="k">def</span> <span class="nf">make_lgr_idomain</span><span class="p">(</span><span class="n">parent_modelgrid</span><span class="p">,</span> <span class="n">inset_modelgrid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Inactivate cells in parent_modelgrid that coincide</span>
<span class="sd">    with area of inset_modelgrid.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">parent_modelgrid</span><span class="o">.</span><span class="n">rotation</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">inset_modelgrid</span><span class="o">.</span><span class="n">rotation</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Rotated grids not supported.&#39;</span><span class="p">)</span>
    <span class="n">idomain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">parent_modelgrid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">inset_modelgrid</span><span class="o">.</span><span class="n">bounds</span>
    <span class="n">isinset</span> <span class="o">=</span> <span class="p">(</span><span class="n">parent_modelgrid</span><span class="o">.</span><span class="n">xcellcenters</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">)</span> <span class="o">&amp;</span> \
              <span class="p">(</span><span class="n">parent_modelgrid</span><span class="o">.</span><span class="n">xcellcenters</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">&amp;</span> \
              <span class="p">(</span><span class="n">parent_modelgrid</span><span class="o">.</span><span class="n">ycellcenters</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> \
              <span class="p">(</span><span class="n">parent_modelgrid</span><span class="o">.</span><span class="n">ycellcenters</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">idomain</span><span class="p">[:,</span> <span class="n">isinset</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">idomain</span></div>


<div class="viewcode-block" id="make_idomain"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.make_idomain">[docs]</a><span class="k">def</span> <span class="nf">make_idomain</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">botm</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=-</span><span class="mi">9999</span><span class="p">,</span>
                 <span class="n">minimum_layer_thickness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">drop_thin_cells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make the idomain array for MODFLOW 6 that specifies</span>
<span class="sd">    cells that will be excluded from the simulation. Cells are</span>
<span class="sd">    excluded based on:</span>
<span class="sd">    1) np.nans or nodata values in the botm array</span>
<span class="sd">    2) np.nans or nodata values in the top array (applies to the highest cells with valid botm elevations;</span>
<span class="sd">    in other words, these cells have no thicknesses)</span>
<span class="sd">    3) layer thicknesses less than the specified minimum thickness plus a tolerance (tol)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : mfsetup.MF6model model instance</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idomain : np.ndarray (int)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">botm</span> <span class="o">=</span> <span class="n">botm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">top</span><span class="p">[</span><span class="n">top</span> <span class="o">==</span> <span class="n">nodata</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">botm</span><span class="p">[</span><span class="n">botm</span> <span class="o">==</span> <span class="n">nodata</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">botm</span><span class="p">)</span>

    <span class="c1"># compute layer thicknesses, considering pinched cells (nans)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">get_layer_thicknesses</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">botm</span><span class="p">)</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="n">criteria</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># cells without thickness values</span>

    <span class="k">if</span> <span class="n">drop_thin_cells</span><span class="p">:</span>
        <span class="n">criteria</span> <span class="o">=</span> <span class="n">criteria</span> <span class="o">|</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">minimum_layer_thickness</span> <span class="o">+</span> <span class="n">tol</span><span class="p">)</span>
        <span class="c1">#all_layers = np.stack([top] + [b for b in botm])</span>
        <span class="c1">#min_layer_thickness = minimum_layer_thickness</span>
        <span class="c1">#isthin = np.diff(all_layers, axis=0) * -1 &lt; min_layer_thickness + tol</span>
        <span class="c1">#criteria = criteria | isthin</span>
    <span class="n">idomain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="o">~</span><span class="n">criteria</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">idomain</span></div>


<div class="viewcode-block" id="get_highest_active_layer"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.get_highest_active_layer">[docs]</a><span class="k">def</span> <span class="nf">get_highest_active_layer</span><span class="p">(</span><span class="n">idomain</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=-</span><span class="mi">9999</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the highest active model layer at each</span>
<span class="sd">    i, j location, accounting for inactive and</span>
<span class="sd">    vertical pass-through cells.&quot;&quot;&quot;</span>
    <span class="n">idm</span> <span class="o">=</span> <span class="n">idomain</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># reset all inactive/passthrough values to large positive value</span>
    <span class="c1"># for min calc</span>
    <span class="n">idm</span><span class="p">[</span><span class="n">idm</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9999</span>
    <span class="n">highest_active_layer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">idm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># set locations with all inactive cells to null values</span>
    <span class="n">highest_active_layer</span><span class="p">[(</span><span class="n">idm</span> <span class="o">==</span> <span class="mi">9999</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">null_value</span>
    <span class="k">return</span> <span class="n">highest_active_layer</span></div>


<div class="viewcode-block" id="make_irch"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.make_irch">[docs]</a><span class="k">def</span> <span class="nf">make_irch</span><span class="p">(</span><span class="n">idomain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make an irch array for the MODFLOW 6 Recharge Package,</span>
<span class="sd">    which specifies the highest active model layer at each</span>
<span class="sd">    i, j location, accounting for inactive and</span>
<span class="sd">    vertical pass-through cells. Set all i, j locations</span>
<span class="sd">    with no active layers to 1 (MODFLOW 6 only allows</span>
<span class="sd">    valid layer numbers in the irch array).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">irch</span> <span class="o">=</span> <span class="n">get_highest_active_layer</span><span class="p">(</span><span class="n">idomain</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=-</span><span class="mi">9999</span><span class="p">)</span>
    <span class="c1"># set locations where all layers are inactive back to 0</span>
    <span class="n">irch</span><span class="p">[</span><span class="n">irch</span> <span class="o">==</span> <span class="o">-</span><span class="mi">9999</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">irch</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># set to one-based</span>
    <span class="k">return</span> <span class="n">irch</span></div>


<div class="viewcode-block" id="get_layer_thicknesses"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.get_layer_thicknesses">[docs]</a><span class="k">def</span> <span class="nf">get_layer_thicknesses</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">botm</span><span class="p">,</span> <span class="n">idomain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For each i, j location in the grid, get thicknesses</span>
<span class="sd">    between pairs of subsequent valid elevation values. Make</span>
<span class="sd">    a thickness array of the same shape as the model grid, assign the</span>
<span class="sd">    computed thicknesses for each pair of valid elevations to the</span>
<span class="sd">    position of the elevation representing the cell botm. For example,</span>
<span class="sd">    given the column of cells [nan nan  8. nan nan nan nan nan  2. nan],</span>
<span class="sd">    a thickness of 6 would be assigned to the second to last layer</span>
<span class="sd">    (position -2).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    top : nrow x ncol array of model top elevations</span>
<span class="sd">    botm : nlay x nrow x ncol array of model botm elevations</span>
<span class="sd">    idomain : nlay x nrow x ncol array indicating cells to be</span>
<span class="sd">        included in the model solution. idomain=0 are converted to np.nans</span>
<span class="sd">        in the example column of cells above. (optional)</span>
<span class="sd">        If idomain is not specified, excluded cells are expected to be</span>
<span class="sd">        designated in the top and botm arrays as np.nans.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Make a fake model grid with 7 layers, but only top and two layer bottoms specified:</span>
<span class="sd">    &gt;&gt;&gt; top = np.reshape([[10]]* 4, (2, 2))</span>
<span class="sd">    &gt;&gt;&gt; botm = np.reshape([[np.nan,  8., np.nan, np.nan, np.nan,  2., np.nan]]*4, (2, 2, 7)).transpose(2, 0, 1)</span>
<span class="sd">    &gt;&gt;&gt; result = get_layer_thicknesses(top, botm)</span>
<span class="sd">    &gt;&gt;&gt; result[:, 0, 0]</span>
<span class="sd">    array([nan  2. nan nan nan  6. nan])</span>

<span class="sd">    example with all layer elevations specified</span>
<span class="sd">    note: this is the same result that np.diff(... axis=0) would produce;</span>
<span class="sd">    except positive in the direction of the zero axis</span>
<span class="sd">    &gt;&gt;&gt; top = np.reshape([[10]] * 4, (2, 2))</span>
<span class="sd">    &gt;&gt;&gt; botm = np.reshape([[9, 8., 8, 6, 3, 2., -10]] * 4, (2, 2, 7)).transpose(2, 0, 1)</span>
<span class="sd">    &gt;&gt;&gt; result = get_layer_thicknesses(top, botm)</span>
<span class="sd">    array([1.,  1., 0., 2., 3.,  1., 12.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;computing cell thicknesses...&#39;</span><span class="p">)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">botm</span> <span class="o">=</span> <span class="n">botm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">idomain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">idomain</span> <span class="o">=</span> <span class="n">idomain</span> <span class="o">&gt;=</span> <span class="mi">1</span>
        <span class="n">top</span><span class="p">[</span><span class="o">~</span><span class="n">idomain</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">botm</span><span class="p">[</span><span class="o">~</span><span class="n">idomain</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">all_layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">top</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">botm</span><span class="p">])</span>
    <span class="n">thicknesses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">botm</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrow</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncol</span><span class="p">):</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="n">all_layers</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">valid_b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cells</span><span class="p">)]))</span>
            <span class="n">b_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">has_top</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">elev</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cells</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">has_top</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">elev</span><span class="p">):</span>
                    <span class="n">has_top</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">has_top</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">elev</span><span class="p">):</span>
                    <span class="n">b_ij</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_b</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">thicknesses</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_ij</span>
    <span class="n">thicknesses</span><span class="p">[</span><span class="n">thicknesses</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># get rid of -0.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;finished in </span><span class="si">{:.2f}</span><span class="s2">s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">thicknesses</span></div>


<div class="viewcode-block" id="weighted_average_between_layers"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.weighted_average_between_layers">[docs]</a><span class="k">def</span> <span class="nf">weighted_average_between_layers</span><span class="p">(</span><span class="n">arr0</span><span class="p">,</span> <span class="n">arr1</span><span class="p">,</span> <span class="n">weight0</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">weight0</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">weight0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">arr0</span><span class="p">,</span> <span class="n">arr1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="populate_values"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.populate_values">[docs]</a><span class="k">def</span> <span class="nf">populate_values</span><span class="p">(</span><span class="n">values_dict</span><span class="p">,</span> <span class="n">array_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given an input dictionary with non-consecutive keys,</span>
<span class="sd">    make a second dictionary with consecutive keys, with values</span>
<span class="sd">    that are linearly interpolated from the first dictionary,</span>
<span class="sd">    based on the key values. For example, given {0: 1.0, 2: 2.0},</span>
<span class="sd">    {0: 1.0, 1: 1.5, 2: 2.0} would be returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; populate_values({0: 1.0, 2: 2.0}, array_shape=None)</span>
<span class="sd">    {0: 1.0, 1: 1.5, 2: 2.0}</span>
<span class="sd">    &gt;&gt;&gt; populate_values({0: 1.0, 2: 2.0}, array_shape=(2, 2))</span>
<span class="sd">    {0: array([[1., 1.],</span>
<span class="sd">               [1., 1.]]),</span>
<span class="sd">     1: array([[1.5, 1.5],</span>
<span class="sd">               [1.5, 1.5]]),</span>
<span class="sd">     2: array([[2., 2.],</span>
<span class="sd">               [2., 2.]])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sorted_layers</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">values_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_layers</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="n">sorted_layers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="n">sorted_layers</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">values_dict</span><span class="p">[</span><span class="n">l1</span><span class="p">]</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">values_dict</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">interp_values</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">layers</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">))))</span>

        <span class="c1"># if an array shape is given, fill an array of that shape</span>
        <span class="c1"># or reshape to that shape</span>
        <span class="k">if</span> <span class="n">array_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">interp_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">array_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">array_shape</span><span class="p">)</span>
                <span class="n">interp_values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">values</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">interp_values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span></div>


<div class="viewcode-block" id="voxels_to_layers"><a class="viewcode-back" href="../../api/mfsetup.discretization.html#mfsetup.discretization.voxels_to_layers">[docs]</a><span class="k">def</span> <span class="nf">voxels_to_layers</span><span class="p">(</span><span class="n">voxel_array</span><span class="p">,</span> <span class="n">z_edges</span><span class="p">,</span> <span class="n">model_top</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_botm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">no_data_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                     <span class="n">extend_top</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extend_botm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                     <span class="n">minimum_frac_active_cells</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine a voxel array (voxel_array), with no-data values and either uniform or non-uniform top</span>
<span class="sd">    and bottom elevations, with land-surface elevations (model_top; to form the top of the grid), and</span>
<span class="sd">    additional elevation surfaces forming layering below the voxel grid (model_botm).</span>

<span class="sd">        * In places where the model_botm elevations are above the lowest voxel elevations,</span>
<span class="sd">          the voxels are given priority, and the model_botm elevations reset to equal the lowest voxel elevations</span>
<span class="sd">          (effectively giving the underlying layer zero-thickness).</span>
<span class="sd">        * Voxels with no_data_value(s) are also given zero-thickness. Typically these would be cells beyond a</span>
<span class="sd">          no-flow boundary, or below the depth of investigation (for example, in an airborne electromagnetic survey</span>
<span class="sd">          of aquifer electrical resisitivity). The vertical extent of the layering representing the voxel data then spans the highest and lowest valid voxels.</span>
<span class="sd">        * In places where the model_top (typically land-surface) elevations are higher than the highest valid voxel,</span>
<span class="sd">          the voxel layer can either be extended to the model_top (extend_top=True), or an additional layer</span>
<span class="sd">          can be created between the top edge of the highest voxel and model_top (extent_top=False).</span>
<span class="sd">        * Similarly, in places where elevations in model_botm are below the lowest valid voxel, the lowest voxel</span>
<span class="sd">          elevation can be extended to the highest underlying layer (extend_botm=True), or an additional layer can fill</span>
<span class="sd">          the gap between the lowest voxel and highest model_botm (extend_botm=False).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    voxel_array : 3D numpy array</span>
<span class="sd">        3D array of voxel data- could be zones or actually aquifer properties. Empty voxels</span>
<span class="sd">        can be marked with a no_data_value. Voxels are assumed to have the same horizontal</span>
<span class="sd">        discretization as the model_top and model_botm layers.</span>
<span class="sd">    z_edges : 3D numpy array or sequence</span>
<span class="sd">        Top and bottom edges of the voxels (length is voxel_array.shape[0] + 1). A sequence</span>
<span class="sd">        can be used to specify uniform voxel edge elevations; non-uniform top and bottom</span>
<span class="sd">        elevations can be specified with a 3D numpy array (similar to the botm array in MODFLOW).</span>
<span class="sd">    model_top : 2D numpy array</span>
<span class="sd">        Top elevations of the model at each row/column location.</span>
<span class="sd">    model_botm : 2D or 3D numpy array</span>
<span class="sd">        Model layer(s) underlying the voxel grid.</span>
<span class="sd">    no_data_value : scalar, optional</span>
<span class="sd">        Indicates empty voxels in voxel_array.</span>
<span class="sd">    extend_top : bool, optional</span>
<span class="sd">        Option to extend the top voxel layer to the model_top, by default True.</span>
<span class="sd">    extend_botm : bool, optional</span>
<span class="sd">        Option to extend the bottom voxel layer to the next layer below in model_botm,</span>
<span class="sd">        by default False.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Depth tolerance used in comparing the voxel edges to model_top and model_botm.</span>
<span class="sd">        For example, if model_top - z_edges[0] is less than tol, the model_top and top voxel</span>
<span class="sd">        edge will be considered equal, and no additional layer will be added, regardless of extend_top.</span>
<span class="sd">        by default 0.1</span>
<span class="sd">    minimum_frac_active_cells : float</span>
<span class="sd">        Minimum fraction of cells with a thickness of &gt; 0 for a layer to be retained,</span>
<span class="sd">        by default 0.01.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    layers : 3D numpy array of shape (nlay +1, nrow, ncol)</span>
<span class="sd">        Model layer elevations (vertical edges of cells), including the model top.</span>


<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If z_edges is not 1D or 3D</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model_top</span> <span class="o">=</span> <span class="n">model_top</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">model_botm</span> <span class="o">=</span> <span class="n">model_botm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_botm</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">model_botm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model_botm</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">model_botm</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">z_edges</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Nan values in z_edges array not allowed!&quot;</span><span class="p">)</span>
    <span class="n">z_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z_edges</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># convert nodata values to nans</span>
    <span class="n">hasdata</span> <span class="o">=</span> <span class="n">voxel_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">hasdata</span><span class="p">[</span><span class="n">hasdata</span> <span class="o">==</span> <span class="n">no_data_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">hasdata</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hasdata</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">thicknesses</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">z_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># apply nodata to thicknesses and botm elevations</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">hasdata</span> <span class="o">*</span> <span class="n">z_values</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">hasdata</span> <span class="o">*</span> <span class="n">thicknesses</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">hasdata</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_values</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">hasdata</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">thicknesses</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;z_edges.shape = </span><span class="si">{}</span><span class="s1">; z_edges must be a 3D or 1D numpy array&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">)]))</span>
    <span class="n">b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># cumulative sum from bottom to top</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># add in the model bottom elevations</span>
    <span class="c1"># use the minimum values instead of the bottom layer,</span>
    <span class="c1"># in case there are nans in the bottom layer</span>
    <span class="n">layers</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># botm[-1]</span>
    <span class="c1"># append the model bottom elevations</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layers</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># set all voxel edges greater than land surface to land surface</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">layers</span> <span class="o">&gt;</span> <span class="n">model_top</span><span class="p">)</span>
    <span class="n">layers</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_top</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

    <span class="c1"># reset model bottom to lowest valid voxels, where they are lower than model bottom</span>
    <span class="n">lowest_valid_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">layers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer_botm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model_botm</span><span class="p">):</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">layer_botm</span> <span class="o">&gt;</span> <span class="n">lowest_valid_edges</span>
        <span class="n">model_botm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">lowest_valid_edges</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

    <span class="c1"># option to add another layer on top of voxel sequence,</span>
    <span class="c1"># if any part of the model top is above the highest valid voxel edges</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">model_top</span> <span class="o">-</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">extend_top</span><span class="p">:</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model_top</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">model_top</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span> <span class="n">layers</span><span class="p">])</span>
    <span class="c1"># otherwise set the top edges of the voxel sequence to be consistent with model top</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_top</span>

    <span class="c1"># option to add additional layers below the voxel sequence,</span>
    <span class="c1"># if any part of those layers in model botm array are below the lowest valid voxel edges</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">extend_botm</span><span class="p">:</span>
        <span class="n">new_botms</span> <span class="o">=</span> <span class="p">[</span><span class="n">layers</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">layer_botm</span> <span class="ow">in</span> <span class="n">model_botm</span><span class="p">:</span>
            <span class="c1"># get the percentage of active cells with &gt; 0 thickness</span>
            <span class="n">pct_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">layers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">layer_botm</span> <span class="o">+</span> <span class="n">tol</span><span class="p">)</span><span class="o">/</span><span class="n">layers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="k">if</span> <span class="n">pct_cells</span> <span class="o">&gt;</span> <span class="n">minimum_frac_active_cells</span><span class="p">:</span>
                <span class="n">new_botms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">layer_botm</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">layer_botm</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
            <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">new_botms</span><span class="p">)</span>
    <span class="c1"># otherwise just set the lowest voxel edges to the highest layer in model botm</span>
    <span class="c1"># (model botm was already set to lowest valid voxels that were lower than the model botm;</span>
    <span class="c1">#  this extends any voxels that were above the model botm to the model botm)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">layers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_botm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># finally, fill any remaining nans with next layer elevation (going upward)</span>
    <span class="c1"># might still have nans in areas where there are no voxel values, but model top and botm values</span>
    <span class="n">top</span><span class="p">,</span> <span class="n">botm</span> <span class="o">=</span> <span class="n">fill_cells_vertically</span><span class="p">(</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span> <span class="n">botm</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">layers</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2023, Modflow-setup developers |.
      <span class="lastupdated">Last updated on Jul 25, 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>