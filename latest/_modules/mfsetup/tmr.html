

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>mfsetup.tmr &mdash; modflow-setup 0.post258+g2de0f7d documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> modflow-setup
          

          
          </a>

          
            
            
              <div class="version">
                0.post258+g2de0f7d
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../philosophy.html">     Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html"> Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html"> Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config-file-gallery.html"> Configuration File Gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../structure.html"> Basic program structure and usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config-file.html"> The configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts/index.html"> Concepts and methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html"> Input instructions by package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html"> Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html"> Code reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config-file-defaults.html"> Configuration file defaults</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release-history.html"> Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html"> Contributing to modflow-setup</a></li>
</ul>
<p class="caption"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../references.html"> References cited</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">modflow-setup</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>mfsetup.tmr</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mfsetup.tmr</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span> <span class="nn">flopy</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">MultiLineString</span>

<span class="n">fm</span> <span class="o">=</span> <span class="n">flopy</span><span class="o">.</span><span class="n">modflow</span>
<span class="kn">from</span> <span class="nn">flopy.utils</span> <span class="kn">import</span> <span class="n">binaryfile</span> <span class="k">as</span> <span class="n">bf</span>
<span class="kn">from</span> <span class="nn">flopy.utils.postprocessing</span> <span class="kn">import</span> <span class="n">get_water_table</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>

<span class="kn">from</span> <span class="nn">mfsetup.discretization</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">find_remove_isolated_cells</span><span class="p">,</span>
    <span class="n">weighted_average_between_layers</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">mfsetup.fileio</span> <span class="kn">import</span> <span class="n">check_source_files</span>
<span class="kn">from</span> <span class="nn">mfsetup.grid</span> <span class="kn">import</span> <span class="n">get_ij</span>
<span class="kn">from</span> <span class="nn">mfsetup.interpolate</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_source_dest_model_xys</span><span class="p">,</span>
    <span class="n">interp_weights</span><span class="p">,</span>
    <span class="n">interpolate</span><span class="p">,</span>
    <span class="n">regrid</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">mfsetup.lakes</span> <span class="kn">import</span> <span class="n">get_horizontal_connections</span>
<span class="kn">from</span> <span class="nn">mfsetup.sourcedata</span> <span class="kn">import</span> <span class="n">ArraySourceData</span>
<span class="kn">from</span> <span class="nn">mfsetup.units</span> <span class="kn">import</span> <span class="n">convert_length_units</span>


<span class="k">class</span> <span class="nc">Tmr</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for basic telescopic mesh refinement of a MODFLOW model.</span>
<span class="sd">    Handles the case where the pfl_nwt grid is a rectangle exactly aligned with</span>
<span class="sd">    the parent grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent_model : flopy.modflow.Modflow instance of parent model</span>
<span class="sd">        Must have a valid, attached ModelGrid (modelgrid) attribute.</span>
<span class="sd">    inset_model : flopy.modflow.Modflow instance of pfl_nwt model</span>
<span class="sd">        Must have a valid, attached ModelGrid (modelgrid) attribute.</span>
<span class="sd">        ModelGrid of pfl_nwt and parent models is used to determine cell</span>
<span class="sd">        connections.</span>
<span class="sd">    parent_head_file : filepath</span>
<span class="sd">        MODFLOW binary head output</span>
<span class="sd">    parent_cell_budget_file : filepath</span>
<span class="sd">        MODFLOW binary cell budget output</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assumptions:</span>
<span class="sd">    * Uniform parent and pfl_nwt grids, with equal delr and delc spacing.</span>
<span class="sd">    * Inset model upper right corner coincides with an upper right corner of a cell</span>
<span class="sd">      in the parent model</span>
<span class="sd">    * Inset cell spacing is a factor of the parent cell spacing</span>
<span class="sd">      (so that each pfl_nwt cell is only connected horizontally to one parent cell).</span>
<span class="sd">    * Inset model row/col dimensions are multiples of parent model cells</span>
<span class="sd">      (no parent cells that only partially overlap the pfl_nwt model)</span>
<span class="sd">    * Horizontally, fluxes are uniformly distributed to child cells within a parent cell. The</span>
<span class="sd">    * Vertically, fluxes are distributed based on transmissivity (sat. thickness x Kh) of</span>
<span class="sd">    pfl_nwt model layers.</span>
<span class="sd">    * The pfl_nwt model is fully penetrating. Total flux through each column of parent cells</span>
<span class="sd">    is equal to the total flux through the corresponding columns of connected pfl_nwt model cells.</span>
<span class="sd">    The get_inset_boundary_flux_side verifies this with an assertion statement.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flow_component</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="s1">&#39;fff&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span> <span class="s1">&#39;fff&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;frf&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;frf&#39;</span><span class="p">}</span>
    <span class="n">flow_sign</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_model</span><span class="p">,</span> <span class="n">inset_model</span><span class="p">,</span>
                 <span class="n">parent_head_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_cell_budget_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">parent_length_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inset_length_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">inset_parent_layer_mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">inset_parent_period_mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inset</span> <span class="o">=</span> <span class="n">inset_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">_set_parent_modelgrid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cbc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_layer_mapping</span> <span class="o">=</span> <span class="n">inset_parent_layer_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_period_mapping</span> <span class="o">=</span> <span class="n">inset_parent_period_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpth</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># path to parent heads output file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cpth</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># path to parent cell budget output file</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pi0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pj0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pi1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pj1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pi_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pj_list</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">parent_length_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent_length_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;parent&#39;</span><span class="p">][</span><span class="s1">&#39;length_units&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">inset_length_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inset_length_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">length_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length_unit_conversion</span> <span class="o">=</span> <span class="n">convert_length_units</span><span class="p">(</span><span class="n">parent_length_units</span><span class="p">,</span> <span class="n">inset_length_units</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">parent_head_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent_head_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">model_ws</span><span class="p">,</span>
                                     <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.hds&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">parent_head_file</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hpth</span> <span class="o">=</span> <span class="n">parent_cell_budget_file</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hpth</span> <span class="o">=</span> <span class="n">parent_head_file</span>
        <span class="k">if</span> <span class="n">parent_cell_budget_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">extension</span> <span class="ow">in</span> <span class="s1">&#39;cbc&#39;</span><span class="p">,</span> <span class="s1">&#39;cbb&#39;</span><span class="p">:</span>
                <span class="n">parent_cell_budget_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">model_ws</span><span class="p">,</span>
                                         <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">extension</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">parent_cell_budget_file</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cpth</span> <span class="o">=</span> <span class="n">parent_cell_budget_file</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cpth</span> <span class="o">=</span> <span class="n">parent_cell_budget_file</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No head or cell budget output files found for parent model </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="c1"># get bounding cells in parent model for pfl_nwt model</span>
        <span class="n">irregular_domain</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># see if irregular domain</span>
        <span class="n">irregbound_cfg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;perimeter_boundary&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;source_data&#39;</span><span class="p">,{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;irregular_boundary&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">irregbound_cfg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">irregular_domain</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">irregbound_cfg</span><span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;perimeter_boundary&#39;</span>
            <span class="n">irregbound_cfg</span><span class="p">[</span><span class="s1">&#39;dest_model&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span>


            <span class="n">sd</span> <span class="o">=</span> <span class="n">ArraySourceData</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">irregbound_cfg</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
            <span class="n">idm_outline</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">connections</span> <span class="o">=</span> <span class="n">get_horizontal_connections</span><span class="p">(</span><span class="n">idm_outline</span><span class="p">,</span> <span class="n">connection_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">layer_elevations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                             <span class="n">delr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inside</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pi_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj_list</span> <span class="o">=</span> <span class="n">connections</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span> <span class="n">connections</span><span class="o">.</span><span class="n">j</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="c1"># otherwise just get the corners of the inset if rectangular domain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pi0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj0</span> <span class="o">=</span> <span class="n">get_ij</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">xcellcenters</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">ycellcenters</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pi1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj1</span> <span class="o">=</span> <span class="n">get_ij</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">xcellcenters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">ycellcenters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_nrow_in_inset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi0</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_ncol_in_inset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj0</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># check for an even number of inset cells per parent cell in x and y directions</span>
        <span class="n">x_refinement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">delr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">delr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_refinement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">delc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">delc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;inset </span><span class="si">{0}</span><span class="s2"> of </span><span class="si">{1:.2f}</span><span class="s2"> </span><span class="si">{2}</span><span class="s2"> must be factor of parent </span><span class="si">{0}</span><span class="s2"> of </span><span class="si">{3:.2f}</span><span class="s2"> </span><span class="si">{4}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_refinement</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x_refinement</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;delr&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">delr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">length_units</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">delr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">length_units</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_refinement</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y_refinement</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;delc&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">delc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">length_units</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">delc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">length_units</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x_refinement</span><span class="p">,</span> <span class="n">y_refinement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;grid must have same x and y discretization&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refinement</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_refinement</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inset_parent_layer_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nlay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nlay</span>
        <span class="c1"># if mapping between source and dest model layers isn&#39;t specified</span>
        <span class="c1"># use property from dest model</span>
        <span class="c1"># this will be the DIS package layer mapping if specified</span>
        <span class="c1"># otherwise same layering is assumed for both models</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_layer_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">parent_layers</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_layer_mapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nspecified</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_layer_mapping</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nspecified</span> <span class="o">!=</span> <span class="n">nlay</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Variable should have </span><span class="si">{}</span><span class="s2"> layers &quot;</span>
                                <span class="s2">&quot;but only </span><span class="si">{}</span><span class="s2"> are specified: </span><span class="si">{}</span><span class="s2">&quot;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nlay</span><span class="p">,</span> <span class="n">nspecified</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_layer_mapping</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_layer_mapping</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inset_parent_period_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nper</span>
        <span class="c1"># if mapping between source and dest model periods isn&#39;t specified</span>
        <span class="c1"># assume one to one mapping of stress periods between models</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_period_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent_periods</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nper</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_period_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">parent_periods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nper</span> <span class="k">else</span> <span class="n">parent_periods</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nper</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_period_mapping</span>

    <span class="nd">@inset_parent_period_mapping</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inset_parent_period_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inset_parent_period_mapping</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_period_mapping</span> <span class="o">=</span> <span class="n">inset_parent_period_mapping</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_source_grid_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean array indicating window in parent model grid (subset of cells)</span>
<span class="sd">        that encompass the pfl_nwt model domain. Used to speed up interpolation</span>
<span class="sd">        of parent grid values onto pfl_nwt grid.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">ncol</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">parent_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">xcellcenters</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">parent_mask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span>
                <span class="n">pi</span><span class="p">,</span> <span class="n">pj</span> <span class="o">=</span> <span class="n">get_ij</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">pad</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">pi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="n">pad</span><span class="p">,</span> <span class="n">pi</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">pad</span>
                <span class="n">j0</span><span class="p">,</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">pj</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="n">pad</span><span class="p">,</span> <span class="n">pj</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">pad</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interp_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For a given parent, only calculate interpolation weights</span>
<span class="sd">        once to speed up re-gridding of arrays to pfl_nwt.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">source_xy</span><span class="p">,</span> <span class="n">dest_xy</span> <span class="o">=</span> <span class="n">get_source_dest_model_xys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span>
                                                           <span class="n">source_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_grid_mask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interp_weights</span> <span class="o">=</span> <span class="n">interp_weights</span><span class="p">(</span><span class="n">source_xy</span><span class="p">,</span> <span class="n">dest_xy</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp_weights</span>

    <span class="k">def</span> <span class="nf">regrid_from_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_array</span><span class="p">,</span>
                                 <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate values in source array onto</span>
<span class="sd">        the destination model grid, using SpatialReference instances</span>
<span class="sd">        attached to the source and destination models.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_array : ndarray</span>
<span class="sd">            Values from source model to be interpolated to destination grid.</span>
<span class="sd">            1 or 2-D numpy array of same sizes as a</span>
<span class="sd">            layer of the source model.</span>
<span class="sd">        mask : ndarray (bool)</span>
<span class="sd">            1 or 2-D numpy array of same sizes as a</span>
<span class="sd">            layer of the source model. True values</span>
<span class="sd">            indicate cells to include in interpolation,</span>
<span class="sd">            False values indicate cells that will be</span>
<span class="sd">            dropped.</span>
<span class="sd">        method : str (&#39;linear&#39;, &#39;nearest&#39;)</span>
<span class="sd">            Interpolation method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">regrid</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span>
                          <span class="n">mask1</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                          <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">parent_values</span> <span class="o">=</span> <span class="n">source_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_grid_mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
            <span class="n">regridded</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">parent_values</span><span class="p">,</span>
                                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">interp_weights</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="n">regridded</span> <span class="o">=</span> <span class="n">regrid</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span>
                               <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="n">regridded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">regridded</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">regridded</span>

    <span class="k">def</span> <span class="nf">get_parent_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get i, j locations in parent model along boundary of pfl_nwt model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pi0, pj0 : ints</span>
<span class="sd">            Parent cell coinciding with origin (0, 0) cell of pfl_nwt model</span>
<span class="sd">        pi1, pj1 : ints</span>
<span class="sd">            Parent cell coinciding with lower right corner of pfl_nwt model</span>
<span class="sd">            (location nrow, ncol)</span>
<span class="sd">        side : str</span>
<span class="sd">            Side of pfl_nwt model (&#39;left&#39;, &#39;bottom&#39;, &#39;right&#39;, or &#39;top&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        i, j : 1D arrays of ints</span>
<span class="sd">            i, j locations of parent cells along pfl_nwt model boundary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pi0</span><span class="p">,</span> <span class="n">pj0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj0</span>
        <span class="n">pi1</span><span class="p">,</span> <span class="n">pj1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj1</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Add a plus 1 because rounded to the nearest 10 for the rows and columns above.</span>
        <span class="n">parent_height</span> <span class="o">=</span> <span class="n">pi1</span> <span class="o">-</span> <span class="n">pi0</span>  <span class="c1"># +1</span>
        <span class="n">parent_width</span> <span class="o">=</span> <span class="n">pj1</span> <span class="o">-</span> <span class="n">pj0</span>  <span class="c1"># +1</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;top&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">parent_width</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi0</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> \
                   <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pj0</span><span class="p">,</span> <span class="n">pj1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pi0</span><span class="p">,</span> <span class="n">pi1</span><span class="p">),</span> \
                   <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">parent_height</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">pj0</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">parent_width</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> \
                   <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pj0</span><span class="p">,</span> <span class="n">pj1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pi0</span><span class="p">,</span> <span class="n">pi1</span><span class="p">),</span> \
                   <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">parent_height</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">pj1</span><span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">get_inset_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
                        <span class="n">side</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get boundary cells in pfl_nwt model corresponding to parent cells i, j.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i, j : int</span>
<span class="sd">            Cell in parent model connected to boundary of pfl_nwt model.</span>
<span class="sd">        pi0, pj0 : int</span>
<span class="sd">            Parent cell coinciding with origin (0, 0) cell of pfl_nwt model</span>
<span class="sd">        refinement : int</span>
<span class="sd">            Refinement level (i.e. 10 if there are 10 pfl_nwt cells for every parent cell).</span>
<span class="sd">        side : str</span>
<span class="sd">            Side of pfl_nwt model (&#39;left&#39;, &#39;bottom&#39;, &#39;right&#39;, or &#39;top&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        i, j : 1D arrays of ints</span>
<span class="sd">            Corresponding i, j locations along boundary of pfl_nwt grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pi0</span><span class="p">,</span> <span class="n">pj0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj0</span>
        <span class="n">refinement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;top&#39;</span><span class="p">:</span>
            <span class="n">ij0</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">pj0</span><span class="p">)</span> <span class="o">*</span> <span class="n">refinement</span>
            <span class="n">ij1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">ij0</span> <span class="o">+</span> <span class="n">refinement</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">ncol</span><span class="p">])</span>
            <span class="n">ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ij0</span><span class="p">,</span> <span class="n">ij1</span><span class="p">)</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ij</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="n">ii0</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">pi0</span><span class="p">)</span> <span class="o">*</span> <span class="n">refinement</span>
            <span class="n">ii1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">ii0</span> <span class="o">+</span> <span class="n">refinement</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nrow</span><span class="p">])</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ii0</span><span class="p">,</span> <span class="n">ii1</span><span class="p">)</span>
            <span class="n">ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="n">ii0</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">pi0</span><span class="p">)</span> <span class="o">*</span> <span class="n">refinement</span>
            <span class="n">ii1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">ii0</span> <span class="o">+</span> <span class="n">refinement</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nrow</span><span class="p">])</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ii0</span><span class="p">,</span> <span class="n">ii1</span><span class="p">)</span>
            <span class="n">ij0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([(</span><span class="n">j</span> <span class="o">-</span> <span class="n">pj0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">refinement</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">ncol</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ij0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span>
            <span class="c1"># Needed to adjust</span>
            <span class="n">ij0</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">pj0</span><span class="p">)</span> <span class="o">*</span> <span class="n">refinement</span>
            <span class="n">ij1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">ij0</span> <span class="o">+</span> <span class="n">refinement</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">ncol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ij0</span><span class="p">,</span> <span class="n">ij1</span><span class="p">)</span>
            <span class="n">ii0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([(</span><span class="n">i</span> <span class="o">-</span> <span class="n">pi0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">refinement</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nrow</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ii0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ij</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ij</span>

    <span class="k">def</span> <span class="nf">get_inset_boundary_flux_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute fluxes between parent and pfl_nwt models on a side;</span>
<span class="sd">        assuming that flux to among connecting child cells</span>
<span class="sd">        is horizontally uniform within a parent cell, but can vary</span>
<span class="sd">        vertically based on transmissivity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        side : str</span>
<span class="sd">            Side of pfl_nwt model (top, bottom, right, left)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : DataFrame</span>
<span class="sd">            Columns k, i, j, Q; describing locations and boundary flux</span>
<span class="sd">            quantities for the pfl_nwt model side.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_cells</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
        <span class="n">nlay_inset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nlay</span>

        <span class="n">Qside</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># boundary fluxes</span>
        <span class="n">kside</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># k locations of boundary fluxes</span>
        <span class="n">iside</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># i locations ...</span>
        <span class="n">jside</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">parent_cells</span><span class="p">):</span>

            <span class="c1"># get the pfl_nwt model cells</span>
            <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_inset_cells</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>

            <span class="c1"># parent model flow and layer bottoms</span>
            <span class="n">Q_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cbc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_component</span><span class="p">[</span><span class="n">side</span><span class="p">]][:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_sign</span><span class="p">[</span><span class="n">side</span><span class="p">]</span>
            <span class="n">botm_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">botm</span><span class="o">.</span><span class="n">array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

            <span class="c1"># pfl_nwt model bottoms, and K</span>
            <span class="c1"># assume equal transmissivity for child cell to a parent cell, within each layer</span>
            <span class="c1"># (use average child cell k and thickness for each layer)</span>
            <span class="c1"># These are the layer bottoms for the pfl_nwt</span>
            <span class="n">botm_inset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">botm</span><span class="o">.</span><span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="c1"># These are the ks from the pfl_nwt model</span>
            <span class="n">kh_inset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">upw</span><span class="o">.</span><span class="n">hk</span><span class="o">.</span><span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># determine aquifer top</span>
            <span class="n">water_table_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">top_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

            <span class="n">Q_inset_ij</span> <span class="o">=</span> <span class="n">distribute_parent_fluxes_to_inset</span><span class="p">(</span><span class="n">Q_parent</span><span class="o">=</span><span class="n">Q_parent</span><span class="p">,</span>
                                                           <span class="n">botm_parent</span><span class="o">=</span><span class="n">botm_parent</span><span class="p">,</span>
                                                           <span class="n">top_parent</span><span class="o">=</span><span class="n">top_parent</span><span class="p">,</span>
                                                           <span class="n">botm_inset</span><span class="o">=</span><span class="n">botm_inset</span><span class="p">,</span>
                                                           <span class="n">kh_inset</span><span class="o">=</span><span class="n">kh_inset</span><span class="p">,</span>
                                                           <span class="n">water_table_parent</span><span class="o">=</span><span class="n">water_table_parent</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement</span> <span class="c1"># no partial parent cells</span>
            <span class="n">Qside</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Q_inset_ij</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">kside</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nlay_inset</span><span class="p">))</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
            <span class="n">iside</span> <span class="o">+=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ii</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">*</span> <span class="n">nlay_inset</span><span class="p">)</span>
            <span class="n">jside</span> <span class="o">+=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">jj</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">*</span> <span class="n">nlay_inset</span><span class="p">)</span>

        <span class="c1"># check that fluxes for the side match the parent</span>
        <span class="n">Qparent_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_boundary_fluxes_side</span><span class="p">(</span><span class="n">parent_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                            <span class="n">parent_cells</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                            <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qparent_side</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Qside</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">kside</span><span class="p">,</span>
                             <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="n">iside</span><span class="p">,</span>
                             <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="n">jside</span><span class="p">,</span>
                             <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="n">Qside</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">get_inset_boundary_fluxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kstpkper</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Get all boundary fluxes for a stress period.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kstpkper : tuple or list of tuples</span>
<span class="sd">            zero-based (timestep, stress period)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : DataFrame of all pfl_nwt model boundary fluxes</span>
<span class="sd">            With columns k, i, j, flux, and per</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="s1">&#39;UPW&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">get_package_list</span><span class="p">(),</span> <span class="s2">&quot;need UPW package to get boundary fluxes&quot;</span>
        <span class="k">assert</span> <span class="s1">&#39;DIS&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">get_package_list</span><span class="p">(),</span> <span class="s2">&quot;need DIS package to get boundary fluxes&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kstpkper</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">kstpkper</span> <span class="o">=</span> <span class="p">[</span><span class="n">kstpkper</span><span class="p">]</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;getting boundary fluxes from </span><span class="si">{}</span><span class="s1">...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cpth</span><span class="p">))</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">kstpkper</span><span class="p">:</span>
            <span class="n">hdsobj</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">HeadFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hpth</span><span class="p">)</span>
            <span class="n">hds</span> <span class="o">=</span> <span class="n">hdsobj</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">kstpkper</span><span class="o">=</span><span class="n">kp</span><span class="p">)</span>
            <span class="n">hdry</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9999</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wt</span> <span class="o">=</span> <span class="n">get_water_table</span><span class="p">(</span><span class="n">hds</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=</span><span class="n">hdry</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">read_parent_cbc_per</span><span class="p">(</span><span class="n">kstpkper</span><span class="o">=</span><span class="n">kp</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
                <span class="n">Qside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_inset_boundary_flux_side</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
                <span class="n">Qside</span><span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qside</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>

        <span class="c1"># check that Qnet out of the parent model equals</span>
        <span class="c1"># the derived fluxes on the pfl_nwt side</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="k">for</span> <span class="n">per</span><span class="p">,</span> <span class="n">dfp</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;per&#39;</span><span class="p">):</span>

            <span class="n">Qnet_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_boundary_net_flux</span><span class="p">(</span><span class="n">kstpkper</span><span class="o">=</span><span class="n">per</span><span class="p">)</span>
            <span class="n">Qnet_inset</span> <span class="o">=</span> <span class="n">dfp</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qnet_parent</span> <span class="o">-</span> <span class="n">Qnet_inset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;finished in </span><span class="si">{:.2f}</span><span class="s2">s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">read_parent_cbc_per</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kstpkper</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="n">cbbobj</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">CellBudgetFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cpth</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;FLOW RIGHT FACE&#39;</span><span class="p">:</span> <span class="s1">&#39;frf&#39;</span><span class="p">,</span>
                <span class="s1">&#39;FLOW FRONT FACE&#39;</span><span class="p">:</span> <span class="s1">&#39;fff&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cbc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">fulltxt</span><span class="p">,</span> <span class="n">shorttxt</span> <span class="ow">in</span> <span class="n">text</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cbc</span><span class="p">[</span><span class="n">shorttxt</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_surface_bc_flux</span><span class="p">(</span><span class="n">cbbobj</span><span class="p">,</span> <span class="n">fulltxt</span><span class="p">,</span>
                                                     <span class="n">kstpkper</span><span class="o">=</span><span class="n">kstpkper</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_parent_boundary_fluxes_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">kstpkper</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Get boundary fluxes at a sequence of i, j locations</span>
<span class="sd">        in the parent model, for a specified side of the pfl_nwt model,</span>
<span class="sd">        for a given stress period.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : sequence of i locations</span>
<span class="sd">        j : sequence of j locations</span>
<span class="sd">        side : str</span>
<span class="sd">            left, right, top or bottom</span>
<span class="sd">        kstpkper : tuple</span>
<span class="sd">            (timestep, Stress Period)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Qside_parent : 2D array</span>
<span class="sd">            Boundary fluxes through parent cells, along side of pfl_nwt model.</span>
<span class="sd">            Signed with respect to pfl_nwt model (i.e., for flow through the</span>
<span class="sd">            left face of the parent cells, into the right side of the</span>
<span class="sd">            pfl_nwt model, the sign is positive (flow into the pfl_nwt model),</span>
<span class="sd">            even though MODFLOW fluxes are right-positive.</span>
<span class="sd">            Shape: (n parent layers, len(i, j))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_parent_cbc_per</span><span class="p">(</span><span class="n">kstpkper</span><span class="o">=</span><span class="n">kstpkper</span><span class="p">)</span>
        <span class="n">Qside_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cbc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_component</span><span class="p">[</span><span class="n">side</span><span class="p">]][:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_sign</span><span class="p">[</span><span class="n">side</span><span class="p">]</span>
        <span class="c1">#Qside_inset = self.get_inset_boundary_flux_side(side)</span>

        <span class="k">return</span> <span class="n">Qside_parent</span>

    <span class="k">def</span> <span class="nf">get_parent_boundary_net_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kstpkper</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kstpkper : int, Stress Period</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Qnet_parent : float</span>
<span class="sd">            Net flux from parent model, summed from parent cell by cell flow results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Qnet_parent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">side</span><span class="p">,</span> <span class="n">flow_sign</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_sign</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parent_cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_cells</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
            <span class="n">Qnet_parent</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_boundary_fluxes_side</span><span class="p">(</span><span class="n">parent_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                <span class="n">parent_cells</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                                <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span>
                                                                <span class="n">kstpkper</span><span class="o">=</span><span class="n">kstpkper</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Qnet_parent</span>

    <span class="k">def</span> <span class="nf">compare_specified_flux_budgets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kstpkper</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">outfile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">kstp</span><span class="p">,</span> <span class="n">per</span> <span class="o">=</span> <span class="n">kstpkper</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="c1"># get pfl_nwt boundary fluxes from scratch, or attached wel package</span>
        <span class="k">if</span> <span class="s1">&#39;WEL&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">get_package_list</span><span class="p">():</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_inset_boundary_fluxes</span><span class="p">(</span><span class="n">kstpkper</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kstpkper</span><span class="p">))</span>
            <span class="n">components</span><span class="p">[</span><span class="s1">&#39;Boundary flux&#39;</span><span class="p">][</span><span class="s1">&#39;pfl_nwt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">wel</span><span class="o">.</span><span class="n">stress_period_data</span><span class="p">[</span><span class="n">per</span><span class="p">]</span>
            <span class="n">rowsides</span> <span class="o">=</span> <span class="p">(</span><span class="n">spd</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">spd</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nrow</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># only count the corners onces</span>
            <span class="n">colsides</span> <span class="o">=</span> <span class="p">((</span><span class="n">spd</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">spd</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">ncol</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">spd</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">spd</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nrow</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">isboundary</span> <span class="o">=</span> <span class="n">rowsides</span> <span class="o">|</span> <span class="n">colsides</span>
            <span class="n">components</span><span class="p">[</span><span class="s1">&#39;Boundary flux (WEL)&#39;</span><span class="p">][</span><span class="s1">&#39;pfl_nwt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spd</span><span class="p">[</span><span class="n">isboundary</span><span class="p">][</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">components</span><span class="p">[</span><span class="s1">&#39;Boundary flux (WEL)&#39;</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_boundary_net_flux</span><span class="p">(</span><span class="n">kstpkper</span><span class="o">=</span><span class="n">kstpkper</span><span class="p">)</span>
            <span class="c1"># (wells besides boundary flux wells)</span>
            <span class="n">components</span><span class="p">[</span><span class="s1">&#39;Pumping (WEL)&#39;</span><span class="p">][</span><span class="s1">&#39;pfl_nwt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spd</span><span class="p">[</span><span class="o">~</span><span class="n">isboundary</span><span class="p">][</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="s1">&#39;WEL&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">get_package_list</span><span class="p">():</span>
            <span class="n">spd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">wel</span><span class="o">.</span><span class="n">stress_period_data</span><span class="p">[</span><span class="n">per</span><span class="p">]</span>
            <span class="n">in_inset</span> <span class="o">=</span> <span class="p">(</span><span class="n">spd</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi0</span><span class="p">)</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">spd</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi1</span><span class="p">)</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">spd</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj0</span><span class="p">)</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">spd</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj1</span><span class="p">)</span>
            <span class="n">components</span><span class="p">[</span><span class="s1">&#39;Pumping (WEL)&#39;</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spd</span><span class="p">[</span><span class="n">in_inset</span><span class="p">][</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># compare attached recharge packages</span>
        <span class="n">r_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">rch</span><span class="o">.</span><span class="n">rech</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">per</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">r_parent_in_inset</span> <span class="o">=</span> <span class="n">r_parent</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pi0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">pi1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">pj0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">pj1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">rsum_parent_in_inset</span> <span class="o">=</span> <span class="n">r_parent_in_inset</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> \
                               <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">delr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">rsum_inset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">rch</span><span class="o">.</span><span class="n">rech</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">per</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> \
                     <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">delr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

        <span class="n">components</span><span class="p">[</span><span class="s1">&#39;Recharge&#39;</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsum_parent_in_inset</span>
        <span class="n">components</span><span class="p">[</span><span class="s1">&#39;Recharge&#39;</span><span class="p">][</span><span class="s1">&#39;pfl_nwt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsum_inset</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">components</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">components</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rpd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;pfl_nwt&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">outfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dest</span><span class="p">:</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;component parent pfl_nwt rpd</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">components</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">dest</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{parent}</span><span class="s1"> </span><span class="si">{inset}</span><span class="s1"> </span><span class="si">{rpd:.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">v</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;component parent pfl_nwt rpd&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">components</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{parent}</span><span class="s1"> </span><span class="si">{inset}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">v</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_inset_boundary_heads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">for_external_files</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="c1"># source data</span>
        <span class="n">headfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpth</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e30</span><span class="p">,</span> <span class="mf">1e30</span><span class="p">,</span>
        <span class="n">check_source_files</span><span class="p">([</span><span class="n">headfile</span><span class="p">])</span>
        <span class="n">hdsobj</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">HeadFile</span><span class="p">(</span><span class="n">headfile</span><span class="p">)</span> <span class="c1">#, precision=&#39;single&#39;)</span>
        <span class="n">all_kstpkper</span> <span class="o">=</span> <span class="n">hdsobj</span><span class="o">.</span><span class="n">get_kstpkper</span><span class="p">()</span>

        <span class="c1"># get the last timestep in each stress period if there are more than one</span>
        <span class="c1">#kstpkper = []</span>
        <span class="c1">#unique_kper = []</span>
        <span class="c1">#for (kstp, kper) in all_kstpkper:</span>
        <span class="c1">#    if kper not in unique_kper:</span>
        <span class="c1">#        kstpkper.append((kstp, kper))</span>
        <span class="c1">#        unique_kper.append(kper)</span>
        <span class="n">last_steps</span> <span class="o">=</span> <span class="p">{</span><span class="n">kper</span><span class="p">:</span> <span class="n">kstp</span> <span class="k">for</span> <span class="n">kstp</span><span class="p">,</span> <span class="n">kper</span> <span class="ow">in</span> <span class="n">all_kstpkper</span><span class="p">}</span>

        <span class="c1">#assert len(unique_kper) == len(set(self.copy_stress_periods)), \</span>
        <span class="c1">#&quot;read {} from {},\nexpected stress periods: {}&quot;.format(kstpkper,</span>
        <span class="c1">#                                                       headfile,</span>
        <span class="c1">#                                                       sorted(list(set(self.copy_stress_periods)))</span>
        <span class="c1">#                                                       )</span>

        <span class="c1"># get active cells along model edge</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">get_boundary_cells</span><span class="p">(</span><span class="n">exclude_inactive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ktmp</span> <span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">clay</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nlay</span><span class="p">):</span>
                <span class="n">ktmp</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">clay</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pi_list</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">itmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nlay</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi_list</span>
            <span class="n">jtmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nlay</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pj_list</span>

            <span class="c1"># get rid of cells that are inactive</span>
            <span class="n">wh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">idomain</span><span class="o">.</span><span class="n">array</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">activecells</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">wh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">wh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">wh</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>
            <span class="n">chdcells</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="n">kk</span><span class="p">,</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">,</span><span class="n">kk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itmp</span><span class="p">,</span><span class="n">jtmp</span><span class="p">,</span><span class="n">ktmp</span><span class="p">)])</span>
            <span class="n">active_chd_cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">chdcells</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">activecells</span><span class="p">))</span>

            <span class="c1"># unpack back to lists, then convert to numpy arrays</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">active_chd_cells</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="c1"># get heads from parent model</span>
        <span class="c1"># TODO: generalize head extraction from parent model using 3D interpolation</span>

        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parent_periods</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">inset_per</span><span class="p">,</span> <span class="n">parent_per</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset_parent_period_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># skip getting data if parent period is already represented</span>
            <span class="c1"># (heads will be reused)</span>
            <span class="k">if</span> <span class="n">parent_per</span> <span class="ow">in</span> <span class="n">parent_periods</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent_periods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent_per</span><span class="p">)</span>
            <span class="n">parent_kstpkper</span> <span class="o">=</span> <span class="n">last_steps</span><span class="p">[</span><span class="n">parent_per</span><span class="p">],</span> <span class="n">parent_per</span>
            <span class="n">hds</span> <span class="o">=</span> <span class="n">hdsobj</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">kstpkper</span><span class="o">=</span><span class="n">parent_kstpkper</span><span class="p">)</span>

            <span class="n">regridded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nlay</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">dest_k</span><span class="p">,</span> <span class="n">source_k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset_parent_layer_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># destination model layers copied from source model layers</span>
                <span class="k">if</span> <span class="n">source_k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">hds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">source_k</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">source_k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">source_k</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">hds</span><span class="p">[</span><span class="n">source_k</span><span class="p">]</span>
                <span class="c1"># destination model layers that are a weighted average</span>
                <span class="c1"># of consecutive source model layers</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weight0</span> <span class="o">=</span> <span class="n">source_k</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">source_k</span><span class="p">)</span>
                    <span class="n">source_k0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">source_k</span><span class="p">))</span>
                    <span class="c1"># first layer in the average can&#39;t be negative</span>
                    <span class="n">source_k0</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">source_k0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">source_k0</span>
                    <span class="n">source_k1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">source_k</span><span class="p">))</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">weighted_average_between_layers</span><span class="p">(</span><span class="n">hds</span><span class="p">[</span><span class="n">source_k0</span><span class="p">],</span>
                                                          <span class="n">hds</span><span class="p">[</span><span class="n">source_k1</span><span class="p">],</span>
                                                          <span class="n">weight0</span><span class="o">=</span><span class="n">weight0</span><span class="p">)</span>
                <span class="c1"># interpolate from source model using source model grid</span>
                <span class="c1"># exclude invalid values in interpolation from parent model</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_grid_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">arr</span> <span class="o">&gt;</span> <span class="n">vmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">arr</span> <span class="o">&lt;</span> <span class="n">vmax</span><span class="p">)</span>

                <span class="n">regriddedk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_from_parent</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>

                <span class="k">assert</span> <span class="n">regriddedk</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">regridded</span><span class="p">[</span><span class="n">dest_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">regriddedk</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_unit_conversion</span>

            <span class="c1"># drop heads in dry cells, but only in mf6</span>
            <span class="c1"># too much trouble with interpolated heads in mf2005</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">regridded</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;mf6&#39;</span><span class="p">:</span>
                <span class="n">wet</span> <span class="o">=</span> <span class="n">head</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">botm</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">head</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

            <span class="c1"># make a DataFrame of regridded heads at perimeter cell locations</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;per&#39;</span><span class="p">:</span> <span class="n">inset_per</span><span class="p">,</span>
                               <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="n">wet</span><span class="p">],</span>
                               <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">[</span><span class="n">wet</span><span class="p">],</span>
                               <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="n">j</span><span class="p">[</span><span class="n">wet</span><span class="p">],</span>
                               <span class="s1">&#39;head&#39;</span><span class="p">:</span> <span class="n">head</span><span class="p">[</span><span class="n">wet</span><span class="p">]</span>
                               <span class="p">})</span>
            <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>

        <span class="c1"># convert to one-based and comment out header if df will be written straight to external file</span>
        <span class="k">if</span> <span class="n">for_external_files</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="s1">&#39;#k&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;#k&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">df</span>


<div class="viewcode-block" id="distribute_parent_fluxes_to_inset"><a class="viewcode-back" href="../../api/mfsetup.tmr.html#mfsetup.tmr.distribute_parent_fluxes_to_inset">[docs]</a><span class="k">def</span> <span class="nf">distribute_parent_fluxes_to_inset</span><span class="p">(</span><span class="n">Q_parent</span><span class="p">,</span> <span class="n">botm_parent</span><span class="p">,</span> <span class="n">top_parent</span><span class="p">,</span>
                                      <span class="n">botm_inset</span><span class="p">,</span> <span class="n">kh_inset</span><span class="p">,</span> <span class="n">water_table_parent</span><span class="p">,</span>
                                      <span class="n">phiramp</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Redistributes a vertical column of parent model fluxes at a single</span>
<span class="sd">    location i, j in the parent model, to the corresponding layers in the</span>
<span class="sd">    pfl_nwt model, based on pfl_nwt model layer transmissivities, accounting for the</span>
<span class="sd">    position of the water table in the parent model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Q_parent : 1D array,</span>
<span class="sd">        Vertical column of horizontal fluxes through a cell face</span>
<span class="sd">        at a location at a location i, j in the parent model.</span>
<span class="sd">        (Length is n parent layers)</span>
<span class="sd">    botm_parent : 1D array</span>
<span class="sd">        Layer bottom elevations at location i, j in parent model.</span>
<span class="sd">        (Length is n parent layers)</span>
<span class="sd">    top_parent : float</span>
<span class="sd">        Top elevation of parent model at location i, j</span>
<span class="sd">    botm_inset : 1D array</span>
<span class="sd">        Mean elevation of pfl_nwt cells along the boundary face, by layer.</span>
<span class="sd">        (Length is n pfl_nwt layers)</span>
<span class="sd">    kh_inset : 1D array</span>
<span class="sd">        Mean hydraulic conductivity of pfl_nwt cells along the boundary face, by layer.</span>
<span class="sd">        (Length is n pfl_nwt layers)</span>
<span class="sd">    water_table_parent : float</span>
<span class="sd">        Water table elevation in parent model.</span>
<span class="sd">    phiramp : float</span>
<span class="sd">        Fluxes in layers with saturated thickness fraction (sat thickness/total cell thickness)</span>
<span class="sd">        below this threshold will be assigned to the next underlying layer with a</span>
<span class="sd">        saturated thickness fraction above this threshold. (default 0.01)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Q_inset : 1D array</span>
<span class="sd">        Vertical column of horizontal fluxes through each layer of the pfl_nwt</span>
<span class="sd">        model, for the group of pfl_nwt model cells corresponding to parent</span>
<span class="sd">        location i, j (represents the sum of horizontal flux through the</span>
<span class="sd">        boundary face of the pfl_nwt model cells in each layer).</span>
<span class="sd">        (Length is n pfl_nwt layers).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check dimensions</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;Length of </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> is </span><span class="si">{2}</span><span class="s2">; &quot;</span> \
          <span class="s2">&quot;length of </span><span class="si">{0}</span><span class="s2"> botm elevation is </span><span class="si">{3}</span><span class="s2">&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Q_parent</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">botm_parent</span><span class="p">),</span> \
        <span class="n">txt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;fluxes&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Q_parent</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">botm_parent</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">botm_inset</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">kh_inset</span><span class="p">),</span> \
        <span class="n">txt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;pfl_nwt&#39;</span><span class="p">,</span> <span class="s1">&#39;kh_inset&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">kh_inset</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">botm_inset</span><span class="p">))</span>

    <span class="c1"># rename variables</span>
    <span class="n">Q1</span> <span class="o">=</span> <span class="n">Q_parent</span>
    <span class="n">botm1</span> <span class="o">=</span> <span class="n">botm_parent</span>
    <span class="n">botm2</span> <span class="o">=</span> <span class="n">botm_inset</span>
    <span class="n">kh2</span> <span class="o">=</span> <span class="n">kh_inset</span>
    <span class="n">aqtop</span> <span class="o">=</span> <span class="n">water_table_parent</span> <span class="k">if</span> <span class="n">water_table_parent</span> <span class="o">&lt;</span> <span class="n">top_parent</span> \
        <span class="k">else</span> <span class="n">top_parent</span>  <span class="c1"># top of the aquifer</span>

    <span class="c1"># Replace nans with 0s bc these are where cells are dry</span>
    <span class="n">Q1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Q1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># In parent model cells with sat thickness fraction less than phiramp,</span>
    <span class="c1"># Distribute flux to next layer with sat thickness frac &gt; phiramp</span>
    <span class="n">b_parent</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">top_parent</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">botm_parent</span><span class="p">)))</span>
    <span class="n">sthick</span> <span class="o">=</span> <span class="n">aqtop</span> <span class="o">-</span> <span class="n">botm_parent</span>
    <span class="n">confined</span> <span class="o">=</span> <span class="p">(</span><span class="n">sthick</span> <span class="o">-</span> <span class="n">b_parent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">sthick</span><span class="p">[</span><span class="n">confined</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_parent</span><span class="p">[</span><span class="n">confined</span><span class="p">]</span>
    <span class="n">stfrac</span> <span class="o">=</span> <span class="n">sthick</span><span class="o">/</span><span class="n">b_parent</span>
    <span class="n">q_excess</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">stfk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stfrac</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stfk</span> <span class="o">&lt;</span> <span class="n">phiramp</span><span class="p">:</span>
            <span class="n">q_excess</span> <span class="o">+=</span> <span class="n">Q1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">Q1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">continue</span>
        <span class="n">Q1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">q_excess</span>
        <span class="n">q_excess</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="n">kh2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kh2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># for any layers below bottom</span>

    <span class="n">nlay1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">botm1</span><span class="p">)</span>
    <span class="n">nlay2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">botm2</span><span class="p">)</span>

    <span class="c1"># all botms in both models, in reverse order (layer-positive)</span>
    <span class="n">allbotms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">botm1</span><span class="p">,</span> <span class="n">botm2</span><span class="p">])))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># list layer numbers in parent and child model;</span>
    <span class="c1"># for each flux connection between them</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">l1</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># layer in parent model</span>
    <span class="n">l2</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># layer in child model</span>
    <span class="k">for</span> <span class="n">botm</span> <span class="ow">in</span> <span class="n">allbotms</span><span class="p">:</span>
        <span class="n">l1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k1</span><span class="p">)</span>
        <span class="n">l2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">botm</span> <span class="ow">in</span> <span class="n">botm1</span><span class="p">:</span>
            <span class="n">k1</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">botm</span> <span class="ow">in</span> <span class="n">botm2</span><span class="p">:</span>
            <span class="n">k2</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">l1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span> <span class="c1"># parent cell connections for pfl_nwt cells</span>
    <span class="n">l2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span> <span class="c1"># pfl_nwt cell connections for parent cells</span>

    <span class="c1"># if bottom of pfl_nwt hangs below bottom of parent;</span>
    <span class="c1"># last layer will &gt;= nlay. Assign T=0 to these intervals.</span>
    <span class="n">l2</span><span class="p">[</span><span class="n">l2</span> <span class="o">&gt;=</span> <span class="n">nlay2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nlay2</span>
    <span class="c1"># include any part of parent model hanging below pfl_nwt</span>
    <span class="c1"># with the lowest layer in the transmissivity calculation</span>
    <span class="n">l1</span><span class="p">[</span><span class="n">l1</span> <span class="o">&gt;=</span> <span class="n">nlay1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nlay1</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># thickness of all layer connections between</span>
    <span class="c1"># parent and child models</span>
    <span class="c1"># (assign 0 for connections above the water table)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">aqtop</span><span class="p">]</span> <span class="o">+</span> <span class="n">allbotms</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b</span><span class="p">[</span><span class="n">allbotms</span> <span class="o">&gt;</span> <span class="n">aqtop</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># get transmissivities</span>
    <span class="n">T2</span> <span class="o">=</span> <span class="n">kh2</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span>
    <span class="n">T1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlay1</span><span class="p">):</span>
        <span class="n">T1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">T2</span><span class="p">[</span><span class="n">l1</span> <span class="o">==</span> <span class="n">k</span><span class="p">]))</span>

    <span class="c1"># get transmissivity fractions (weights)</span>
    <span class="n">tfrac</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># for each parent/pfl_nwt connection</span>
    <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l1</span><span class="p">):</span>
        <span class="c1"># compute transmissivity fraction  (of parent cell)</span>
        <span class="n">itfrac</span> <span class="o">=</span> <span class="n">T2</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">/</span> <span class="n">T1</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="k">if</span> <span class="n">T2</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">tfrac</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">itfrac</span><span class="p">)</span>
    <span class="n">tfrac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tfrac</span><span class="p">)</span>

    <span class="c1"># assign incoming flux to each pfl_nwt/parent connection</span>
    <span class="c1"># multiply by weight</span>
    <span class="n">Qs</span> <span class="o">=</span> <span class="n">Q1</span><span class="p">[</span><span class="n">l1</span><span class="p">]</span> <span class="o">*</span> <span class="n">tfrac</span>

    <span class="c1"># Where nan, make 0</span>
    <span class="n">Qs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Qs</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s1">&#39;../qs.dat&#39;</span><span class="p">,</span> <span class="n">Qs</span><span class="p">)</span>
    <span class="c1"># sum fluxes by pfl_nwt model layer</span>
    <span class="n">Q_inset</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlay2</span><span class="p">):</span>
        <span class="n">Q_inset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qs</span><span class="p">[</span><span class="n">l2</span> <span class="o">==</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

    <span class="c1"># check that total flux through column of cells</span>
    <span class="c1"># matches for pfl_nwt layers and parent layers</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q_parent</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q_inset</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mf">1e-3</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Q_inset</span><span class="p">)</span></div>


<div class="viewcode-block" id="TmrNew"><a class="viewcode-back" href="../../api/mfsetup.tmr.html#mfsetup.tmr.TmrNew">[docs]</a><span class="k">class</span> <span class="nc">TmrNew</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for general telescopic mesh refinement of a MODFLOW model. Head or</span>
<span class="sd">    flux fields from parent model are interpolated to boundary cells of</span>
<span class="sd">    inset model, which may be in any configuration (jagged, rotated, etc.).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent_model : flopy model instance instance of parent model</span>
<span class="sd">        Must have a valid, attached ModelGrid (modelgrid) attribute.</span>
<span class="sd">    inset_model : flopy model instance instance of inset model</span>
<span class="sd">        Must have a valid, attached ModelGrid (modelgrid) attribute.</span>
<span class="sd">    parent_head_file : filepath</span>
<span class="sd">        MODFLOW binary head output</span>
<span class="sd">    parent_cell_budget_file : filepath</span>
<span class="sd">        MODFLOW binary cell budget output</span>
<span class="sd">    define_connections : str, {&#39;max_active_extent&#39;, &#39;by_layer&#39;}</span>
<span class="sd">        Method for defining perimeter cells where the TMR boundary</span>
<span class="sd">        condition will be applied. If &#39;max_active_extent&#39;, the</span>
<span class="sd">        maximum footprint of the active area (including all cell</span>
<span class="sd">        locations with at least one layer that is active) will be used.</span>
<span class="sd">        If &#39;by_layer&#39;, the perimeter of the active area in each layer will be used</span>
<span class="sd">        (excluding any interior clusters of active cells). The &#39;by_layer&#39;</span>
<span class="sd">        option is potentially problematic if some layers have substantial</span>
<span class="sd">        areas of pinched-out (idomain != 1) cells, which may result</span>
<span class="sd">        in perimeter boundary condition cells getting placed too close</span>
<span class="sd">        to the area of interest. By default, &#39;max_active_extent&#39;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_model</span><span class="p">,</span> <span class="n">inset_model</span><span class="p">,</span>
                 <span class="n">parent_head_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_cell_budget_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">boundary_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inset_parent_period_mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">parent_start_date_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">define_connections_by</span><span class="o">=</span><span class="s1">&#39;max_active_extent&#39;</span><span class="p">,</span>
                 <span class="n">shapefile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inset</span> <span class="o">=</span> <span class="n">inset_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_head_file</span> <span class="o">=</span> <span class="n">parent_head_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_cell_budget_file</span> <span class="o">=</span> <span class="n">parent_cell_budget_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">define_connections_by</span> <span class="o">=</span> <span class="n">define_connections_by</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shapefile</span> <span class="o">=</span> <span class="n">shapefile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_type</span> <span class="o">=</span> <span class="n">boundary_type</span>
        <span class="k">if</span> <span class="n">boundary_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parent_head_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_type</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span>
        <span class="k">elif</span> <span class="n">boundary_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parent_cell_budget_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_type</span> <span class="o">=</span> <span class="s1">&#39;flux&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_start_date_time</span> <span class="o">=</span> <span class="n">parent_start_date_time</span>

        <span class="c1"># properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idomain</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inset_boundary_cells</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_period_mapping</span> <span class="o">=</span> <span class="n">inset_parent_period_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interp_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span> <span class="o">=</span> <span class="n">source_mask</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">idomain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Active area of the inset model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idomain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;mf6&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_idomain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">idomain</span><span class="o">.</span><span class="n">array</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_idomain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">bas6</span><span class="o">.</span><span class="n">ibound</span><span class="o">.</span><span class="n">array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idomain</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inset_boundary_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inset_boundary_cells</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">by_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_connections_by</span> <span class="o">==</span> <span class="s1">&#39;by_layer&#39;</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_inset_boundary_cells</span><span class="p">(</span><span class="n">by_layer</span><span class="o">=</span><span class="n">by_layer</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">xyzcellcenters</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">j</span><span class="p">]</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">j</span><span class="p">]</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">j</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inset_boundary_cells</span> <span class="o">=</span> <span class="n">df</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interp_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inset_boundary_cells</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inset_parent_period_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nper</span>
        <span class="c1"># if mapping between source and dest model periods isn&#39;t specified</span>
        <span class="c1"># assume one to one mapping of stress periods between models</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_period_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent_periods</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nper</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_period_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">parent_periods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nper</span> <span class="k">else</span> <span class="n">parent_periods</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nper</span><span class="p">)}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_period_mapping</span>

    <span class="nd">@inset_parent_period_mapping</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inset_parent_period_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inset_parent_period_mapping</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inset_parent_period_mapping</span> <span class="o">=</span> <span class="n">inset_parent_period_mapping</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interp_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For a given parent, only calculate interpolation weights</span>
<span class="sd">        once to speed up re-gridding of arrays to pfl_nwt.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># x, y, z locations of parent model head values</span>
            <span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_xyzcellcenters</span>

            <span class="c1"># x, y, z locations of inset model boundary cells</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset_boundary_cells</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">values</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_interp_weights</span> <span class="o">=</span> <span class="n">interp_weights</span><span class="p">((</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">d</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interp_weights</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp_weights</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parent_xyzcellcenters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get x, y, z locations of parent cells in a buffered area</span>
<span class="sd">        (defined by the _source_grid_mask property) around the</span>
<span class="sd">        inset model.&quot;&quot;&quot;</span>
        <span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">xyzcellcenters</span>

        <span class="c1"># add an extra layer on the top and bottom</span>
        <span class="c1"># for inset model cells above or below</span>
        <span class="c1"># the last cell center in the vert. direction</span>
        <span class="c1"># pad top by top layer thickness</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">top</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">botm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">pz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">b1</span>
        <span class="c1"># pad botm by botm layer thickness</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">botm</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">b1</span>
        <span class="n">botm</span> <span class="o">=</span> <span class="n">pz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b2</span>
        <span class="n">pz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([[</span><span class="n">top</span><span class="p">],</span> <span class="n">pz</span><span class="p">,</span> <span class="p">[</span><span class="n">botm</span><span class="p">]])</span>

        <span class="n">nlay</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span> <span class="o">=</span> <span class="n">pz</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="p">(</span><span class="n">nlay</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">py</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="p">(</span><span class="n">nlay</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_grid_mask</span>
        <span class="c1"># mask already has extra top/botm layers</span>
        <span class="c1"># (_source_grid_mask property)</span>
        <span class="n">px</span> <span class="o">=</span> <span class="n">px</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">py</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">pz</span> <span class="o">=</span> <span class="n">pz</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_source_grid_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean array indicating window in parent model grid (subset of cells)</span>
<span class="sd">        that encompass the pfl_nwt model domain. Used to speed up interpolation</span>
<span class="sd">        of parent grid values onto pfl_nwt grid.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">ncol</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">parent_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">xcellcenters</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">parent_mask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span>
                <span class="n">pi</span><span class="p">,</span> <span class="n">pj</span> <span class="o">=</span> <span class="n">get_ij</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">pad</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">pi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">pi</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">pad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">nrow</span><span class="p">])</span>
                <span class="n">j0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">pj</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">j1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">pj</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">pad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">ncol</span><span class="p">])</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># make the mask 3D</span>
            <span class="c1"># include extra layer for top and bottom edges of model</span>
            <span class="n">mask3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">nlay</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span> <span class="o">=</span> <span class="n">mask3d</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">mask3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">nlay</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span> <span class="o">=</span> <span class="n">mask3d</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_mask</span>

<div class="viewcode-block" id="TmrNew.get_inset_boundary_cells"><a class="viewcode-back" href="../../api/mfsetup.tmr.html#mfsetup.tmr.TmrNew.get_inset_boundary_cells">[docs]</a>    <span class="k">def</span> <span class="nf">get_inset_boundary_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by_layer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shapefile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a dataframe of connection information for</span>
<span class="sd">        horizontal boundary cells.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        by_layer : bool</span>
<span class="sd">            Controls how boundary cells will be defined. If True,</span>
<span class="sd">            the perimeter of the active area in each layer will be used</span>
<span class="sd">            (excluding any interior clusters of active cells). If</span>
<span class="sd">            False, the maximum footprint of the active area</span>
<span class="sd">            (including all cell locations with at least one layer that</span>
<span class="sd">            is active).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">getting perimeter cells...&#39;</span><span class="p">)</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shapefile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shapefile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapefile</span>
        <span class="k">if</span> <span class="n">shapefile</span><span class="p">:</span>
            <span class="n">perimeter</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile</span><span class="p">)</span>
            <span class="n">perimeter</span> <span class="o">=</span> <span class="n">perimeter</span><span class="p">[[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>
            <span class="c1"># reproject the perimeter shapefile to the model CRS if needed</span>
            <span class="k">if</span> <span class="n">perimeter</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
                <span class="n">perimeter</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># convert polygons to linear rings</span>
            <span class="c1"># (so just the cells along the polygon exterior are selected)</span>
            <span class="n">geoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">perimeter</span><span class="o">.</span><span class="n">geometry</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;MultiPolygon&#39;</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">MultiLineString</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">exterior</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">geoms</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Polygon&#39;</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">exterior</span>
                <span class="n">geoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="c1"># add a buffer of 1 cell width so that cells aren&#39;t missed</span>
            <span class="c1"># extra cells will get culled later</span>
            <span class="c1"># when only cells along the outer perimeter (max idomain extent)</span>
            <span class="c1"># are selected</span>
            <span class="n">buffer_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">delr</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">delc</span><span class="o">.</span><span class="n">mean</span><span class="p">()])</span>
            <span class="n">perimeter</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer_dist</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">geoms</span><span class="p">]</span>
            <span class="n">grid_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span><span class="n">layers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">grid_df</span><span class="p">,</span> <span class="n">perimeter</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;intersects&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
            <span class="c1"># add layers</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">nlay</span><span class="p">):</span>
                <span class="n">kdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">kdf</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kdf</span><span class="p">)</span>
            <span class="n">specified_bcells</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>
            <span class="c1"># get the active extent in each layer</span>
            <span class="c1"># and the cell faces along the edge</span>
            <span class="c1"># apply those cell faces to specified_bcells</span>
            <span class="n">by_layer</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">specified_bcells</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">by_layer</span><span class="p">:</span>
            <span class="c1"># get the max footprint of active cells</span>
            <span class="n">max_active_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idomain</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="c1"># fill any holes within the max footprint</span>
            <span class="c1"># including any LGR areas (that are inactive in this model)</span>
            <span class="c1"># set min cluster size to 1 greater than number of inactive cells</span>
            <span class="c1"># (to not allow any holes)</span>
            <span class="n">minimum_cluster_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">max_active_area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># find_remove_isolated_cells fills clusters of 1s with 0s</span>
            <span class="c1"># to fill holes, we want to look for clusters of 0s and fill with 1s</span>
            <span class="c1"># invert the result to get True values for active cells and filled areas</span>
            <span class="n">filled</span> <span class="o">=</span> <span class="o">~</span><span class="n">find_remove_isolated_cells</span><span class="p">(</span><span class="o">~</span><span class="n">max_active_area</span><span class="p">,</span> <span class="n">minimum_cluster_size</span><span class="p">)</span>
            <span class="n">max_active_area</span> <span class="o">=</span> <span class="n">filled</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># pad filled idomain array with zeros around the edge</span>
            <span class="c1"># so that perimeter connections are identified</span>
            <span class="n">filled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">max_active_area</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">filled3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">filled</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idomain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">get_horizontal_connections</span><span class="p">(</span><span class="n">filled3d</span><span class="p">,</span> <span class="n">connection_info</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># deincrement rows and columns</span>
            <span class="c1"># so that they reflect positions in the non-padded array</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">layer_idomain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idomain</span><span class="p">):</span>

                <span class="c1"># just get the perimeter of inactive cells</span>
                <span class="c1"># (exclude any interior active cells)</span>
                <span class="c1"># start by filling any interior active cells</span>
                <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">binary_fill_holes</span>
                <span class="n">binary_idm</span> <span class="o">=</span> <span class="n">layer_idomain</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">filled</span> <span class="o">=</span> <span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">binary_idm</span><span class="p">)</span>
                <span class="c1"># pad filled idomain array with zeros around the edge</span>
                <span class="c1"># so that perimeter connections are identified</span>
                <span class="n">filled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">filled</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># get the cells along the inside edge</span>
                <span class="c1"># of the model active area perimeter,</span>
                <span class="c1"># via a sobel filter</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">get_horizontal_connections</span><span class="p">(</span><span class="n">filled</span><span class="p">,</span> <span class="n">connection_info</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="c1"># deincrement rows and columns</span>
                <span class="c1"># so that they reflect positions in the non-padded array</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>

            <span class="c1"># cull the boundary cells identified above</span>
            <span class="c1"># with the sobel filter on the outer perimeter</span>
            <span class="c1"># to just the cells specified in the shapefile</span>
            <span class="k">if</span> <span class="n">specified_bcells</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cellid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">j</span><span class="p">))</span>
                <span class="n">specified_bcells</span><span class="p">[</span><span class="s1">&#39;cellid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">specified_bcells</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">specified_bcells</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">specified_bcells</span><span class="o">.</span><span class="n">j</span><span class="p">))</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">cellid</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">specified_bcells</span><span class="o">.</span><span class="n">cellid</span><span class="p">)]</span>

        <span class="c1"># add layer top and bottom and idomain information</span>
        <span class="n">layer_tops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">array</span><span class="p">]</span> <span class="o">+</span>
                              <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">botm</span><span class="o">.</span><span class="n">array</span><span class="p">])[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer_tops</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">j</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;botm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">botm</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">j</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;idomain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;mf6&#39;</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;idomain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">idomain</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">j</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s1">&#39;BAS6&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">get_package_list</span><span class="p">():</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;idomain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">bas6</span><span class="o">.</span><span class="n">ibound</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">j</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;cellface&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;botm&#39;</span><span class="p">,</span> <span class="s1">&#39;idomain&#39;</span><span class="p">]]</span>
        <span class="c1"># drop inactive cells</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;idomain&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># get cell polygons from modelgrid</span>
        <span class="c1"># write shapefile of boundary cells with face information</span>
        <span class="n">grid_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">grid_df</span><span class="p">[</span><span class="s1">&#39;cellid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">grid_df</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">grid_df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">grid_df</span><span class="o">.</span><span class="n">j</span><span class="p">))</span>
        <span class="n">geoms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">grid_df</span><span class="p">[</span><span class="s1">&#39;cellid&#39;</span><span class="p">],</span> <span class="n">grid_df</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="s1">&#39;cellid&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cellid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">j</span><span class="p">))</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">geoms</span><span class="p">[</span><span class="n">cellid</span><span class="p">]</span> <span class="k">for</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">cellid</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">modelgrid</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
        <span class="n">outshp</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inset</span><span class="o">.</span><span class="n">_tables_path</span><span class="p">,</span> <span class="s1">&#39;boundary_cells.shp&#39;</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;cellid&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">outshp</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;wrote </span><span class="si">{</span><span class="n">outshp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;perimeter cells took </span><span class="si">{:.2f}</span><span class="s2">s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="TmrNew.get_inset_boundary_values"><a class="viewcode-back" href="../../api/mfsetup.tmr.html#mfsetup.tmr.TmrNew.get_inset_boundary_values">[docs]</a>    <span class="k">def</span> <span class="nf">get_inset_boundary_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">for_external_files</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_type</span> <span class="o">==</span> <span class="s1">&#39;head&#39;</span><span class="p">:</span>
            <span class="n">check_source_files</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_head_file</span><span class="p">])</span>
            <span class="n">hdsobj</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">HeadFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_head_file</span><span class="p">)</span>  <span class="c1"># , precision=&#39;single&#39;)</span>
            <span class="n">all_kstpkper</span> <span class="o">=</span> <span class="n">hdsobj</span><span class="o">.</span><span class="n">get_kstpkper</span><span class="p">()</span>

            <span class="n">last_steps</span> <span class="o">=</span> <span class="p">{</span><span class="n">kper</span><span class="p">:</span> <span class="n">kstp</span> <span class="k">for</span> <span class="n">kstp</span><span class="p">,</span> <span class="n">kper</span> <span class="ow">in</span> <span class="n">all_kstpkper</span><span class="p">}</span>

            <span class="c1"># get the perimeter cells and calculate the weights</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_weights</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">getting perimeter heads...&#39;</span><span class="p">)</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">parent_periods</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">inset_per</span><span class="p">,</span> <span class="n">parent_per</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset_parent_period_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;for stress period </span><span class="si">{</span><span class="n">inset_per</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="c1"># skip getting data if parent period is already represented</span>
                <span class="c1"># (heads will be reused)</span>
                <span class="k">if</span> <span class="n">parent_per</span> <span class="ow">in</span> <span class="n">parent_periods</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">parent_periods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent_per</span><span class="p">)</span>
                <span class="n">parent_kstpkper</span> <span class="o">=</span> <span class="n">last_steps</span><span class="p">[</span><span class="n">parent_per</span><span class="p">],</span> <span class="n">parent_per</span>
                <span class="n">parent_heads</span> <span class="o">=</span> <span class="n">hdsobj</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">kstpkper</span><span class="o">=</span><span class="n">parent_kstpkper</span><span class="p">)</span>
                <span class="c1"># pad the parent heads on the top and bottom</span>
                <span class="c1"># so that inset cells above and below the top/bottom cell centers</span>
                <span class="c1"># will be within the interpolation space</span>
                <span class="c1"># (parent x, y, z locations already contain this pad; parent_xyzcellcenters)</span>
                <span class="n">parent_heads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">parent_heads</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># interpolate inset boundary heads from 3D parent head solution</span>
                <span class="n">heads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_values</span><span class="p">(</span><span class="n">parent_heads</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
                <span class="c1">#heads = griddata((px, py, pz), parent_heads.ravel(),</span>
                <span class="c1">#                  (x, y, z), method=&#39;linear&#39;)</span>

                <span class="c1"># make a DataFrame of interpolated heads at perimeter cell locations</span>
                <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset_boundary_cells</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inset_per</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;head&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">heads</span>

                <span class="c1"># boundary heads must be greater than the cell bottom</span>
                <span class="c1"># and idomain &gt; 0</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;head&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;botm&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;idomain&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
                <span class="c1"># drop invalid heads (most likely due to dry cells)</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;head&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1e10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;head&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">1e10</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
                <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;took </span><span class="si">{:.2f}</span><span class="s2">s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t1</span><span class="p">))</span>

            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>
            <span class="c1"># drop duplicate cells (accounting for stress periods)</span>
            <span class="c1"># (that may have connections in the x and y directions,</span>
            <span class="c1">#  and therefore would be listed twice)</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cellid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">per</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">j</span><span class="p">))</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cellid&#39;</span><span class="p">])</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">duplicates</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;per&#39;</span><span class="p">,</span> <span class="s1">&#39;head&#39;</span><span class="p">]]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;getting perimeter heads took </span><span class="si">{:.2f}</span><span class="s2">s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">))</span>

        <span class="c1"># convert to one-based and comment out header if df will be written straight to external file</span>
        <span class="k">if</span> <span class="n">for_external_files</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="s1">&#39;#k&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;#k&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="TmrNew.interpolate_values"><a class="viewcode-back" href="../../api/mfsetup.tmr.html#mfsetup.tmr.TmrNew.interpolate_values">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_array</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate values in source array onto</span>
<span class="sd">        the destination model grid, using modelgrid instances</span>
<span class="sd">        attached to the source and destination models.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_array : ndarray</span>
<span class="sd">            Values from source model to be interpolated to destination grid.</span>
<span class="sd">            3D numpy array of same shape as the source model.</span>
<span class="sd">        method : str (&#39;linear&#39;, &#39;nearest&#39;)</span>
<span class="sd">            Interpolation method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolated : ndarray</span>
<span class="sd">            3D array of interpolated values at the inset model grid locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_values</span> <span class="o">=</span> <span class="n">source_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_grid_mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">interpolated</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">parent_values</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">interp_weights</span><span class="p">,</span>
                                       <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="c1"># x, y, z locations of parent model head values</span>
            <span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_xyzcellcenters</span>
            <span class="c1"># x, y, z locations of inset model boundary cells</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inset_boundary_cells</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">values</span>
            <span class="n">interpolated</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">((</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span><span class="p">),</span> <span class="n">parent_values</span><span class="p">,</span>
                                    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interpolated</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019-2021, Modflow-setup developers |.
      <span class="lastupdated">
        Last updated on May 14, 2021.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>